--
-- Name: get_run_tracking_monthly_info(text, integer, integer, text); Type: FUNCTION; Schema: public; Owner: d3l243
--

CREATE OR REPLACE FUNCTION public.get_run_tracking_monthly_info(_instrument text, _year integer, _month integer, _options text DEFAULT ''::text) RETURNS TABLE(seq integer, id integer, dataset text, day integer, duration integer, "interval" integer, time_start timestamp without time zone, time_end timestamp without time zone, instrument text, comment_state text, comment text)
    LANGUAGE plpgsql
    AS $$
/****************************************************
**
**  Desc:
**      Returns run tracking information for given instrument
**
**  Arguments:
**    _instrument   'VOrbiETD04'
**    _year         2012
**    _month        1
**    _options      Reserved for future use
**
**  Columns in the query results from this function:
**    seq            -- Sequence ID, generated by this function, ordered by acquisition start time
**    id             -- Dataset_ID
**    dataset        -- Dataset name
**    day            -- Day of the month that acquisition started
**    duration       -- Acquisition length, in minutes
**    Interval       -- Interval (in minutes) following the dataset_id
**    Time_Start     -- Acquisition start time
**    Time_Start     -- Acquisition end time
**    Instrument     -- Instrument name
**    Comment_state  -- 'x' if the dataset is not followed by a long interval;
**                   -- '-' if it has a long interval but the interval does not have a comment
**                   -- '+' if it has a long interval and the interval has a comment defined
**    Comment        -- Long interval comment
**
**  Auth:   grk
**  Date:   02/14/2012 grk - Initial release
**          02/15/2012 grk - Added interval comment handing
**          06/08/2012 grk - Added lookup for _maxNormalInterval
**          04/27/2020 mem - Update data validation checks
**                         - Make several columns in the output table nullable
**          06/23/2022 mem - Ported to PostgreSQL
**          10/22/2022 mem - Directly pass value to function argument
**          05/22/2023 mem - Capitalize reserved words
**          05/30/2023 mem - Replace * with specific column names when returning query results
**
*****************************************************/
DECLARE
    _maxNormalInterval int;
    _message text := '';
    _instrumentID int;
    _firstDayOfStartingMonth timestamp;
    _firstDayOfTrailingMonth timestamp;
    _seqIncrement int := 1;
    _seqOffset int := 0;
    _firstRunSeq int;
    _lastRunSeq int;
    _firstStart timestamp;
    _initialGap int;
    _preceedingDataset record;
    _lastRunStart timestamp;
    _lastRunEnd timestamp;
    _lastRunInterval int;
BEGIN

    CREATE TEMP TABLE Tmp_TX (
        seq int primary key,
        id int NULL,
        dataset text,
        day int NULL,
        duration int NULL,
        "interval" int NULL,
        time_start timestamp NULL,
        time_end timestamp NULL,
        instrument text NULL,
        comment_state text NULL,
        comment text NULL
    );

    ---------------------------------------------------
    -- Check arguments
    ---------------------------------------------------

    If Coalesce(_year, 0) = 0 OR Coalesce(_month, 0) = 0 OR Coalesce(_instrument, '') = '' Then
        INSERT INTO Tmp_TX (seq, dataset)
        VALUES (1, 'Bad arguments');

        RETURN QUERY
        SELECT T.Seq, T.ID, T.Dataset, T.Day, T.Duration, T."interval",
               T.Time_Start, T.Time_End, T.Instrument,
               T.Comment_State, T.Comment
        FROM Tmp_TX T;

        DROP TABLE Tmp_TX;
        RETURN;
    End If;

    ---------------------------------------------------
    -- Get instrument ID
    ---------------------------------------------------

    SELECT InstName.instrument_id
    INTO _instrumentID
    FROM t_instrument_name InstName
    WHERE InstName.instrument = _instrument;

    If Not FOUND Then
        INSERT INTO Tmp_TX (seq, dataset)
        VALUES (1, 'Unrecognized instrument');

        RETURN QUERY
        SELECT T.Seq, T.ID, T.Dataset, T.Day, T.Duration, T."interval",
               T.Time_Start, T.Time_End, T.Instrument,
               T.Comment_State, T.Comment
        FROM Tmp_TX T;

        DROP TABLE Tmp_TX;
        RETURN;
    End If;

    ---------------------------------------------------
    -- Set up dates for beginning and end of month
    ---------------------------------------------------

    _firstDayOfStartingMonth := make_date(_year, _month, 1);
    _firstDayOfTrailingMonth := _firstDayOfStartingMonth + Interval '1 month';

    ---------------------------------------------------
    -- Get datasets whose start time falls within month
    ---------------------------------------------------

    INSERT INTO Tmp_TX ( seq,
                         id,
                         dataset,
                         day,
                         time_Start,
                         time_end,
                         duration,
                         "interval",
                         instrument )
    SELECT (_seqIncrement * ((ROW_NUMBER() OVER ( ORDER BY TD.acq_time_start ASC )) - 1) + 1) + _seqOffset AS seq,
           TD.dataset_id AS id,
           TD.dataset AS dataset,
           Extract(day FROM TD.acq_time_start) AS day,
           TD.acq_time_start AS time_start,
           TD.acq_time_end AS time_end,
           TD.acq_length_minutes AS duration,
           TD.interval_to_next_ds AS "interval",
           _instrument AS instrument
    FROM t_dataset AS TD
    WHERE TD.instrument_id = _instrumentID AND
          TD.acq_time_start >= _firstDayOfStartingMonth AND
          TD.acq_time_start <  _firstDayOfTrailingMonth
    ORDER BY TD.acq_time_start;

    ---------------------------------------------------
    -- Need to add some part of run or interval from
    -- preceding month if first run in month is not
    -- close to beginning of month
    ---------------------------------------------------

    SELECT MAX(Tmp_TX.seq)
    INTO _lastRunSeq
    FROM Tmp_TX;

    SELECT Tmp_TX.time_start
    INTO _firstStart
    FROM Tmp_TX
    WHERE Tmp_TX.seq = _firstRunSeq;

    -- The long interval threshold is 180 minutes
    _maxNormalInterval := public.get_long_interval_threshold();

    -- Get preceeding dataset (latest with starting time preceding this month)
    -- Use "extract(epoch ...) / 60.0" to get the difference in minutes between the two timestamps
    --
    If extract(epoch FROM (_firstStart - _firstDayOfStartingMonth)) / 60.0 > _maxNormalInterval Then
        SELECT TD.dataset_id AS id,
               TD.dataset AS dataset,
               TD.acq_time_start AS start,
               TD.acq_time_end AS end,
               TD.acq_length_minutes AS duration,
               TD.interval_to_next_ds AS "interval"
        INTO _preceedingDataset
        FROM t_dataset AS TD
        WHERE TD.instrument_id = _instrumentID AND
              TD.acq_time_start < _firstDayOfStartingMonth AND
              TD.acq_time_start > _firstDayOfStartingMonth - Interval '90 days'
        ORDER BY TD.acq_time_start DESC
        LIMIT 1;

        _initialGap := extract(epoch FROM (_firstStart - _firstDayOfStartingMonth)) / 60.0;

        -- If preceeding dataset's end time is before start of month, zero the duration and truncate the interval
        -- otherwise just truncate the duration
        --
        If _precEnd < _firstDayOfStartingMonth Then
            _preceedingDataset.duration := 0;
            _preceedingDataset."interval" := _initialGap;
        Else
            _preceedingDataset.duration := extract(epoch FROM (_precStart - _firstDayOfStartingMonth)) / 60.0;
        End If;

        -- Add preceeding dataset record (with truncated duration/interval)
        -- at beginning of results
        --
        INSERT INTO Tmp_TX ( seq,
                             dataset,
                             id,
                             day,
                             time_start,
                             time_end,
                             duration,
                             "interval",
                             instrument )
        VALUES( _firstRunSeq - 1,               -- seq
                _preceedingDataset.dataset,
                _preceedingDataset.id,
                1,                              -- Day of month
                _preceedingDataset.start,
                _preceedingDataset.end,
                _preceedingDataset.duration,
                _preceedingDataset."interval",
                _instrument);
    End If;

    ---------------------------------------------------
    -- Need to truncate part of last run or following
    -- interval that hangs over end of month
    ---------------------------------------------------

    -- If end of last run hangs over start of succeeding month,
    -- truncate duration and set interval to zero

    -- Otherwise, if interval hangs over succeeding month, truncate it
    --
    SELECT Tmp_TX.time_start,
           Tmp_TX.time_end,
           Tmp_TX."interval"       -- Interval, in minutes
    INTO _lastRunStart, _lastRunEnd, _lastRunInterval
    FROM Tmp_TX
    WHERE Tmp_TX.seq = _lastRunSeq;

    If _lastRunEnd > _firstDayOfTrailingMonth Then
        UPDATE Tmp_TX
        SET "interval" = 0,
            duration = extract(epoch FROM (_firstDayOfTrailingMonth - _lastRunStart)) / 60.0
        WHERE Tmp_TX.Seq = _lastRunSeq;
    ElsIf _lastRunEnd + make_interval(mins => _lastRunInterval) > _firstDayOfTrailingMonth Then
        UPDATE Tmp_TX
        SET "interval" = extract(epoch FROM (_firstDayOfTrailingMonth - _lastRunEnd)) / 60.0
        WHERE Tmp_TX.Seq = _lastRunSeq;
    End If;

    ---------------------------------------------------
    -- Fill in interval comment information
    ---------------------------------------------------

    UPDATE Tmp_TX
    SET comment = TRI.comment,
        comment_state = CASE WHEN Coalesce(TRI.comment, '') = ''
                             THEN '-'
                             ELSE '+'
                        END
    FROM t_run_interval TRI
    WHERE Tmp_TX.ID = TRI.interval_id;

    UPDATE Tmp_TX
    SET comment_state = 'x'
    WHERE Tmp_TX.comment_state Is Null;

    RETURN QUERY
    SELECT T.Seq, T.ID, T.Dataset, T.Day, T.Duration, T."interval",
           T.Time_Start, T.Time_End, T.Instrument,
           T.Comment_State, T.Comment
    FROM Tmp_TX T;

    DROP TABLE Tmp_TX;
END
$$;


ALTER FUNCTION public.get_run_tracking_monthly_info(_instrument text, _year integer, _month integer, _options text) OWNER TO d3l243;

--
-- Name: FUNCTION get_run_tracking_monthly_info(_instrument text, _year integer, _month integer, _options text); Type: COMMENT; Schema: public; Owner: d3l243
--

COMMENT ON FUNCTION public.get_run_tracking_monthly_info(_instrument text, _year integer, _month integer, _options text) IS 'GetRunTrackingMonthlyInfo';


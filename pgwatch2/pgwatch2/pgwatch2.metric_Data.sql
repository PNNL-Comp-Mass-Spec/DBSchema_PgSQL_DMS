--
-- PostgreSQL database dump
--

-- Dumped from database version 12.2
-- Dumped by pg_dump version 12.1

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Data for Name: metric; Type: TABLE DATA; Schema: pgwatch2; Owner: pgwatch2
--

COPY pgwatch2.metric (m_id, m_name, m_pg_version_from, m_sql, m_comment, m_is_active, m_is_helper, m_last_modified_on, m_master_only, m_standby_only, m_column_attrs, m_sql_su) FROM stdin;
65	backends	9.0	\nwith sa_snapshot as (\n  select * from get_stat_activity() where not current_query like 'autovacuum:%'\n)\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  (select count(*) from sa_snapshot) as total,\n  (select count(*) from pg_stat_activity where procpid != pg_backend_pid()) as instance_total,\n  current_setting('max_connections')::int as max_connections,\n  (select count(*) from sa_snapshot where current_query != '<IDLE>') as active,\n  (select count(*) from sa_snapshot where current_query = '<IDLE>') as idle,\n  (select count(*) from sa_snapshot where current_query = '<IDLE> in transaction') as idleintransaction,\n  (select count(*) from sa_snapshot where waiting) as waiting,\n  (select extract(epoch from (now() - backend_start))::int\n    from sa_snapshot order by backend_start limit 1) as longest_session_seconds,\n  (select extract(epoch from (now() - xact_start))::int\n    from sa_snapshot where xact_start is not null order by xact_start limit 1) as longest_tx_seconds,\n  (select extract(epoch from (now() - xact_start))::int\n   from get_stat_activity() where current_query like 'autovacuum:%' order by xact_start limit 1) as longest_autovacuum_seconds,\n  (select extract(epoch from max(now() - query_start))::int\n    from sa_snapshot where current_query != '<IDLE>') as longest_query_seconds;\n	\N	t	f	2020-05-05 17:15:29.262509-07	f	f	{"prometheus_all_gauge_columns": true}	\nwith sa_snapshot as (\n  select * from pg_stat_activity\n  where datname = current_database()\n  and not current_query like 'autovacuum:%'\n  and procpid != pg_backend_pid()\n)\nselect\n    (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n    (select count(*) from sa_snapshot) as total,\n    (select count(*) from pg_stat_activity where procpid != pg_backend_pid()) as instance_total,\n    current_setting('max_connections')::int as max_connections,\n    (select count(*) from sa_snapshot where current_query != '<IDLE>') as active,\n    (select count(*) from sa_snapshot where current_query = '<IDLE>') as idle,\n    (select count(*) from sa_snapshot where current_query = '<IDLE> in transaction') as idleintransaction,\n    (select count(*) from sa_snapshot where waiting) as waiting,\n    (select extract(epoch from (now() - backend_start))::int\n     from sa_snapshot order by backend_start limit 1) as longest_session_seconds,\n    (select extract(epoch from (now() - xact_start))::int\n     from sa_snapshot where xact_start is not null order by xact_start limit 1) as longest_tx_seconds,\n    (select extract(epoch from (now() - xact_start))::int\n     from pg_stat_activity where current_query like 'autovacuum:%' order by xact_start limit 1) as longest_autovacuum_seconds,\n    (select extract(epoch from max(now() - query_start))::int\n     from sa_snapshot where current_query != '<IDLE>') as longest_query_seconds;\n
66	backends	9.2	\nwith sa_snapshot as (\n  select * from get_stat_activity() where not query like 'autovacuum:%'\n)\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  (select count(*) from sa_snapshot) as total,\n  (select count(*) from pg_stat_activity where pid != pg_backend_pid()) as instance_total,\n  current_setting('max_connections')::int as max_connections,\n  (select count(*) from sa_snapshot where state = 'active') as active,\n  (select count(*) from sa_snapshot where state = 'idle') as idle,\n  (select count(*) from sa_snapshot where state = 'idle in transaction') as idleintransaction,\n  (select count(*) from sa_snapshot where waiting) as waiting,\n  (select extract(epoch from (now() - backend_start))::int\n    from sa_snapshot order by backend_start limit 1) as longest_session_seconds,\n  (select extract(epoch from (now() - xact_start))::int\n    from sa_snapshot where xact_start is not null order by xact_start limit 1) as longest_tx_seconds,\n  (select extract(epoch from (now() - xact_start))::int\n   from get_stat_activity() where query like 'autovacuum:%' order by xact_start limit 1) as longest_autovacuum_seconds,\n  (select extract(epoch from max(now() - query_start))::int\n    from sa_snapshot where state = 'active') as longest_query_seconds;\n	\N	t	f	2020-05-05 17:15:29.265658-07	f	f	{"prometheus_all_gauge_columns": true}	\nwith sa_snapshot as (\n  select * from pg_stat_activity\n  where datname = current_database()\n  and not query like 'autovacuum:%'\n  and pid != pg_backend_pid()\n)\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  (select count(*) from sa_snapshot) as total,\n  (select count(*) from pg_stat_activity where pid != pg_backend_pid()) as instance_total,\n  current_setting('max_connections')::int as max_connections,\n  (select count(*) from sa_snapshot where state = 'active') as active,\n  (select count(*) from sa_snapshot where state = 'idle') as idle,\n  (select count(*) from sa_snapshot where state = 'idle in transaction') as idleintransaction,\n  (select count(*) from sa_snapshot where waiting) as waiting,\n  (select extract(epoch from (now() - backend_start))::int\n    from sa_snapshot order by backend_start limit 1) as longest_session_seconds,\n  (select extract(epoch from (now() - xact_start))::int\n    from sa_snapshot where xact_start is not null order by xact_start limit 1) as longest_tx_seconds,\n  (select extract(epoch from (now() - xact_start))::int\n   from pg_stat_activity where query like 'autovacuum:%' order by xact_start limit 1) as longest_autovacuum_seconds,\n  (select extract(epoch from max(now() - query_start))::int\n    from sa_snapshot where state = 'active') as longest_query_seconds;\n
67	backends	9.4	\nwith sa_snapshot as (\n  select * from get_stat_activity() where not query like 'autovacuum:%'\n)\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  (select count(*) from sa_snapshot) as total,\n  (select count(*) from pg_stat_activity where pid != pg_backend_pid()) as instance_total,\n  current_setting('max_connections')::int as max_connections,\n  (select count(*) from sa_snapshot where state = 'active') as active,\n  (select count(*) from sa_snapshot where state = 'idle') as idle,\n  (select count(*) from sa_snapshot where state = 'idle in transaction') as idleintransaction,\n  (select count(*) from sa_snapshot where waiting) as waiting,\n  (select extract(epoch from (now() - backend_start))::int\n    from sa_snapshot order by backend_start limit 1) as longest_session_seconds,\n  (select extract(epoch from (now() - xact_start))::int\n    from sa_snapshot where xact_start is not null order by xact_start limit 1) as longest_tx_seconds,\n  (select extract(epoch from (now() - xact_start))::int\n   from get_stat_activity() where query like 'autovacuum:%' order by xact_start limit 1) as longest_autovacuum_seconds,\n  (select extract(epoch from max(now() - query_start))::int\n    from sa_snapshot where state = 'active') as longest_query_seconds,\n  (select max(age(backend_xmin))::int8 from sa_snapshot) as max_xmin_age_tx;\n	\N	t	f	2020-05-05 17:15:29.266458-07	f	f	{"prometheus_all_gauge_columns": true}	\nwith sa_snapshot as (\n  select * from pg_stat_activity\n  where datname = current_database()\n  and not query like 'autovacuum:%'\n  and pid != pg_backend_pid()\n)\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  (select count(*) from sa_snapshot) as total,\n  (select count(*) from pg_stat_activity where pid != pg_backend_pid()) as instance_total,\n  current_setting('max_connections')::int as max_connections,\n  (select count(*) from sa_snapshot where state = 'active') as active,\n  (select count(*) from sa_snapshot where state = 'idle') as idle,\n  (select count(*) from sa_snapshot where state = 'idle in transaction') as idleintransaction,\n  (select count(*) from sa_snapshot where waiting) as waiting,\n  (select extract(epoch from (now() - backend_start))::int\n    from sa_snapshot order by backend_start limit 1) as longest_session_seconds,\n  (select extract(epoch from (now() - xact_start))::int\n    from sa_snapshot where xact_start is not null order by xact_start limit 1) as longest_tx_seconds,\n  (select extract(epoch from (now() - xact_start))::int\n   from pg_stat_activity where query like 'autovacuum:%' order by xact_start limit 1) as longest_autovacuum_seconds,\n  (select extract(epoch from max(now() - query_start))::int\n    from sa_snapshot where state = 'active') as longest_query_seconds,\n  (select max(age(backend_xmin))::int8 from sa_snapshot) as max_xmin_age_tx;\n
68	backends	9.6	\nwith sa_snapshot as (\n  select * from get_stat_activity() where not query like 'autovacuum:%'\n)\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  (select count(*) from sa_snapshot) as total,\n  (select count(*) from pg_stat_activity where pid != pg_backend_pid()) as instance_total,\n  current_setting('max_connections')::int as max_connections,\n  (select count(*) from sa_snapshot where state = 'active') as active,\n  (select count(*) from sa_snapshot where state = 'idle') as idle,\n  (select count(*) from sa_snapshot where state = 'idle in transaction') as idleintransaction,\n  (select count(*) from sa_snapshot where wait_event_type in ('LWLockNamed', 'Lock', 'BufferPin')) as waiting,\n  (select extract(epoch from (now() - backend_start))::int\n    from sa_snapshot order by backend_start limit 1) as longest_session_seconds,\n  (select extract(epoch from (now() - xact_start))::int\n    from sa_snapshot where xact_start is not null order by xact_start limit 1) as longest_tx_seconds,\n  (select extract(epoch from (now() - xact_start))::int\n   from get_stat_activity() where query like 'autovacuum:%' order by xact_start limit 1) as longest_autovacuum_seconds,\n  (select extract(epoch from max(now() - query_start))::int\n    from sa_snapshot where state = 'active') as longest_query_seconds,\n  (select max(age(backend_xmin))::int8 from sa_snapshot) as max_xmin_age_tx;\n	\N	t	f	2020-05-05 17:15:29.267185-07	f	f	{"prometheus_all_gauge_columns": true}	\nwith sa_snapshot as (\n  select * from pg_stat_activity\n  where datname = current_database()\n  and not query like 'autovacuum:%'\n  and pid != pg_backend_pid()\n)\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  (select count(*) from sa_snapshot) as total,\n  (select count(*) from pg_stat_activity where pid != pg_backend_pid()) as instance_total,\n  current_setting('max_connections')::int as max_connections,\n  (select count(*) from sa_snapshot where state = 'active') as active,\n  (select count(*) from sa_snapshot where state = 'idle') as idle,\n  (select count(*) from sa_snapshot where state = 'idle in transaction') as idleintransaction,\n  (select count(*) from sa_snapshot where wait_event_type in ('LWLockNamed', 'Lock', 'BufferPin')) as waiting,\n  (select extract(epoch from (now() - backend_start))::int\n    from sa_snapshot order by backend_start limit 1) as longest_session_seconds,\n  (select extract(epoch from (now() - xact_start))::int\n    from sa_snapshot where xact_start is not null order by xact_start limit 1) as longest_tx_seconds,\n  (select extract(epoch from (now() - xact_start))::int\n   from pg_stat_activity where query like 'autovacuum:%' order by xact_start limit 1) as longest_autovacuum_seconds,\n  (select extract(epoch from max(now() - query_start))::int\n    from sa_snapshot where state = 'active') as longest_query_seconds,\n  (select max(age(backend_xmin))::int8 from sa_snapshot) as max_xmin_age_tx;\n
86	sproc_stats	9.0	\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  schemaname::text AS tag_schema,\n  funcname::text  AS tag_function_name,\n  quote_ident(schemaname)||'.'||quote_ident(funcname) as tag_function_full_name,\n  p.oid::text as tag_oid, -- for overloaded funcs\n  calls as sp_calls,\n  self_time,\n  total_time\nFROM\n  pg_stat_user_functions f\n  JOIN\n  pg_proc p ON p.oid = f.funcid;\n	\N	t	f	2020-05-05 17:15:29.27918-07	f	f	\N	
69	backends	10	\nwith sa_snapshot as (\n  select * from get_stat_activity()\n)\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  (select count(*) from sa_snapshot where backend_type = 'client backend') as total,\n  (select count(*) from pg_stat_activity where pid != pg_backend_pid()) as instance_total,\n  current_setting('max_connections')::int as max_connections,\n  (select count(*) from sa_snapshot where backend_type = 'background worker') as background_workers,\n  (select count(*) from sa_snapshot where state = 'active' and backend_type = 'client backend') as active,\n  (select count(*) from sa_snapshot where state = 'idle' and backend_type = 'client backend') as idle,\n  (select count(*) from sa_snapshot where state = 'idle in transaction' and backend_type = 'client backend') as idleintransaction,\n  (select count(*) from sa_snapshot where wait_event_type in ('LWLock', 'Lock', 'BufferPin') and backend_type = 'client backend') as waiting,\n  (select extract(epoch from (now() - backend_start))::int\n    from sa_snapshot where backend_type = 'client backend' order by backend_start limit 1) as longest_session_seconds,\n  (select extract(epoch from (now() - xact_start))::int\n    from sa_snapshot where xact_start is not null and backend_type = 'client backend' order by xact_start limit 1) as longest_tx_seconds,\n  (select extract(epoch from (now() - xact_start))::int\n    from get_stat_activity() where backend_type = 'autovacuum worker' order by xact_start limit 1) as longest_autovacuum_seconds,\n  (select extract(epoch from max(now() - query_start))::int\n    from sa_snapshot where state = 'active' and backend_type = 'client backend') as longest_query_seconds,\n  (select max(age(backend_xmin))::int8 from sa_snapshot) as max_xmin_age_tx;\n	\N	t	f	2020-05-05 17:15:29.268109-07	f	f	{"prometheus_all_gauge_columns": true}	\nwith sa_snapshot as (\n  select * from pg_stat_activity\n  where pid != pg_backend_pid()\n  and datname = current_database()\n)\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  (select count(*) from sa_snapshot where backend_type = 'client backend') as total,\n  (select count(*) from pg_stat_activity where pid != pg_backend_pid()) as instance_total,\n  current_setting('max_connections')::int as max_connections,\n  (select count(*) from sa_snapshot where backend_type = 'background worker') as background_workers,\n  (select count(*) from sa_snapshot where state = 'active' and backend_type = 'client backend') as active,\n  (select count(*) from sa_snapshot where state = 'idle' and backend_type = 'client backend') as idle,\n  (select count(*) from sa_snapshot where state = 'idle in transaction' and backend_type = 'client backend') as idleintransaction,\n  (select count(*) from sa_snapshot where wait_event_type in ('LWLock', 'Lock', 'BufferPin') and backend_type = 'client backend') as waiting,\n  (select extract(epoch from (now() - backend_start))::int\n    from sa_snapshot where backend_type = 'client backend' order by backend_start limit 1) as longest_session_seconds,\n  (select extract(epoch from (now() - xact_start))::int\n    from sa_snapshot where xact_start is not null and backend_type = 'client backend' order by xact_start limit 1) as longest_tx_seconds,\n  (select extract(epoch from (now() - xact_start))::int\n    from pg_stat_activity where backend_type = 'autovacuum worker' order by xact_start limit 1) as longest_autovacuum_seconds,\n  (select extract(epoch from max(now() - query_start))::int\n    from sa_snapshot where state = 'active' and backend_type = 'client backend') as longest_query_seconds,\n  (select max(age(backend_xmin))::int8 from sa_snapshot) as max_xmin_age_tx;\n
70	bgwriter	9.0	\nselect\n   (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n   checkpoints_timed,\n   checkpoints_req,\n   buffers_checkpoint,\n   buffers_clean,\n   maxwritten_clean,\n   buffers_backend,\n   buffers_alloc\n from\n   pg_stat_bgwriter;\n	\N	t	f	2020-05-05 17:15:29.269322-07	t	f	\N	
71	bgwriter	9.2	\nselect\n   (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n   checkpoints_timed,\n   checkpoints_req,\n   checkpoint_write_time,\n   checkpoint_sync_time,\n   buffers_checkpoint,\n   buffers_clean,\n   maxwritten_clean,\n   buffers_backend,\n   buffers_backend_fsync,\n   buffers_alloc\n from\n   pg_stat_bgwriter;\n	\N	t	f	2020-05-05 17:15:29.269993-07	t	f	\N	
72	cpu_load	9.0	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  round(load_1min::numeric, 2)::float as load_1min,\n  round(load_5min::numeric, 2)::float as load_5min,\n  round(load_15min::numeric, 2)::float as load_15min\nfrom\n  get_load_average();   -- needs the plpythonu proc from "metric_fetching_helpers" folder\n	\N	t	f	2020-05-05 17:15:29.270495-07	f	f	{"prometheus_all_gauge_columns": true}	
73	db_stats	9.0	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  numbackends,\n  xact_commit,\n  xact_rollback,\n  blks_read,\n  blks_hit,\n  tup_returned,\n  tup_fetched,\n  tup_inserted,\n  tup_updated,\n  tup_deleted,\n  extract(epoch from (now() - pg_postmaster_start_time()))::int8 as postmaster_uptime_s,\n  case when pg_is_in_recovery() then 1 else 0 end as in_recovery_int\nfrom\n  pg_stat_database\nwhere\n  datname = current_database();\n	\N	t	f	2020-05-05 17:15:29.271077-07	f	f	{"prometheus_gauge_columns": ["numbackends", "postmaster_uptime_s"]}	
74	db_stats	9.1	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  numbackends,\n  xact_commit,\n  xact_rollback,\n  blks_read,\n  blks_hit,\n  tup_returned,\n  tup_fetched,\n  tup_inserted,\n  tup_updated,\n  tup_deleted,\n  conflicts,\n  extract(epoch from (now() - pg_postmaster_start_time()))::int8 as postmaster_uptime_s,\n  case when pg_is_in_recovery() then 1 else 0 end as in_recovery_int\nfrom\n  pg_stat_database\nwhere\n  datname = current_database();\n	\N	t	f	2020-05-05 17:15:29.271591-07	f	f	{"prometheus_gauge_columns": ["numbackends", "postmaster_uptime_s"]}	
75	db_stats	9.2	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  numbackends,\n  xact_commit,\n  xact_rollback,\n  blks_read,\n  blks_hit,\n  tup_returned,\n  tup_fetched,\n  tup_inserted,\n  tup_updated,\n  tup_deleted,\n  conflicts,\n  temp_files,\n  temp_bytes,\n  deadlocks,\n  blk_read_time,\n  blk_write_time,\n  extract(epoch from (now() - pg_postmaster_start_time()))::int8 as postmaster_uptime_s,\n  case when pg_is_in_recovery() then 1 else 0 end as in_recovery_int\nfrom\n  pg_stat_database\nwhere\n  datname = current_database();\n	\N	t	f	2020-05-05 17:15:29.272107-07	f	f	{"prometheus_gauge_columns": ["numbackends", "postmaster_uptime_s"]}	
76	db_stats	9.3	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  numbackends,\n  xact_commit,\n  xact_rollback,\n  blks_read,\n  blks_hit,\n  tup_returned,\n  tup_fetched,\n  tup_inserted,\n  tup_updated,\n  tup_deleted,\n  conflicts,\n  temp_files,\n  temp_bytes,\n  deadlocks,\n  blk_read_time,\n  blk_write_time,\n  extract(epoch from (now() - pg_postmaster_start_time()))::int8 as postmaster_uptime_s,\n  extract(epoch from (now() - pg_backup_start_time()))::int8 as backup_duration_s,\n  case when pg_is_in_recovery() then 1 else 0 end as in_recovery_int\nfrom\n  pg_stat_database\nwhere\n  datname = current_database();\n	\N	t	f	2020-05-05 17:15:29.272607-07	f	f	{"prometheus_gauge_columns": ["numbackends", "postmaster_uptime_s", "backup_duration_s"]}	
77	db_stats	12	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  numbackends,\n  xact_commit,\n  xact_rollback,\n  blks_read,\n  blks_hit,\n  tup_returned,\n  tup_fetched,\n  tup_inserted,\n  tup_updated,\n  tup_deleted,\n  conflicts,\n  temp_files,\n  temp_bytes,\n  deadlocks,\n  blk_read_time,\n  blk_write_time,\n  extract(epoch from (now() - pg_postmaster_start_time()))::int8 as postmaster_uptime_s,\n  extract(epoch from (now() - pg_backup_start_time()))::int8 as backup_duration_s,\n  checksum_failures,\n  extract(epoch from (now() - checksum_last_failure))::int8 as checksum_last_failure_s,\n  case when pg_is_in_recovery() then 1 else 0 end as in_recovery_int\nfrom\n  pg_stat_database\nwhere\n  datname = current_database();\n	\N	t	f	2020-05-05 17:15:29.273146-07	f	f	{"prometheus_gauge_columns": ["numbackends", "postmaster_uptime_s", "backup_duration_s", "checksum_last_failure_s"]}	
78	db_size	9.0	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  pg_database_size(current_database()) as size_b;\n	\N	t	f	2020-05-05 17:15:29.273625-07	f	f	{"prometheus_all_gauge_columns": true}	
79	index_stats	9.0	\nWITH q_locked_rels AS (\n  select relation from pg_locks where mode = 'AccessExclusiveLock' and granted\n)\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  schemaname::text as tag_schema,\n  indexrelname::text as tag_index_name,\n  quote_ident(schemaname)||'.'||quote_ident(indexrelname) as tag_index_full_name,\n  relname::text as tag_table_name,\n  quote_ident(schemaname)||'.'||quote_ident(relname) as tag_table_full_name,\n  coalesce(idx_scan, 0) as idx_scan,\n  coalesce(idx_tup_read, 0) as idx_tup_read,\n  coalesce(idx_tup_fetch, 0) as idx_tup_fetch,\n  coalesce(pg_relation_size(indexrelid), 0) as index_size_b,\n  quote_ident(schemaname)||'.'||quote_ident(sui.indexrelname) as index_full_name_val,\n  md5(regexp_replace(replace(pg_get_indexdef(sui.indexrelid),indexrelname,'X'), '^CREATE UNIQUE','CREATE')) as tag_index_def_hash,\n  regexp_replace(replace(pg_get_indexdef(sui.indexrelid),indexrelname,'X'), '^CREATE UNIQUE','CREATE') as index_def,\n  case when not i.indisvalid then 1 else 0 end as is_invalid_int,\n  case when i.indisprimary then 1 else 0 end as is_pk_int\nFROM\n  pg_stat_user_indexes sui\n  JOIN\n  pg_index i USING (indexrelid)\nWHERE\n  NOT schemaname like E'pg\\\\_temp%'\n  AND i.indrelid not in (select relation from q_locked_rels)\n  AND i.indexrelid not in (select relation from q_locked_rels)\nORDER BY\n  schemaname, relname, indexrelname;\n	\N	t	f	2020-05-05 17:15:29.274114-07	f	f	{"prometheus_gauge_columns": ["index_size_b", "is_invalid_int", "is_pk_int"]}	
80	kpi	9.0	\nWITH q_stat_tables AS (\n  SELECT * FROM pg_stat_user_tables t\n  JOIN pg_class c ON c.oid = t.relid\n  WHERE NOT schemaname LIKE E'pg\\\\_temp%'\n  AND c.relpages > (1e7 / 8)    -- >10MB\n),\nq_stat_activity AS (\n  SELECT * FROM get_stat_activity()\n)\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  numbackends - 1 as numbackends,\n  (select count(*) from q_stat_activity where not current_query in ('<IDLE>', '<IDLE> in transaction')) AS active_backends,\n  (select count(*) from q_stat_activity where waiting) AS blocked_backends,\n  (select round(extract(epoch from now()) - extract(epoch from (select xact_start from q_stat_activity\n    where datid = d.datid and not current_query like 'autovacuum:%' order by xact_start limit 1))))::int AS kpi_oldest_tx_s,\n  xact_commit + xact_rollback AS tps,\n  xact_commit,\n  xact_rollback,\n  blks_read,\n  blks_hit,\n  (select sum(seq_scan) from q_stat_tables)::int8 AS seq_scans_on_tbls_gt_10mb,\n  tup_inserted,\n  tup_updated,\n  tup_deleted,\n  (select sum(calls) from pg_stat_user_functions where not schemaname like any(array[E'pg\\\\_%', 'information_schema']))::int8 AS sproc_calls,\n  extract(epoch from (now() - pg_postmaster_start_time()))::int8 as postmaster_uptime_s\nFROM\n  pg_stat_database d\nWHERE\n  datname = current_database();\n	\N	t	f	2020-05-05 17:15:29.274687-07	f	f	{"prometheus_gauge_columns": ["numbackends", "active_backends", "blocked_backends", "kpi_oldest_tx_s"]}	\nWITH q_stat_tables AS (\n  SELECT * FROM pg_stat_user_tables t\n  JOIN pg_class c ON c.oid = t.relid\n  WHERE NOT schemaname LIKE E'pg\\\\_temp%'\n  AND c.relpages > (1e7 / 8)    -- >10MB\n),\nq_stat_activity AS (\n  SELECT * FROM pg_stat_activity WHERE procpid != pg_backend_pid() AND datname = current_database()\n)\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  numbackends - 1 as numbackends,\n  (select count(*) from q_stat_activity where not current_query in ('<IDLE>', '<IDLE> in transaction')) AS active_backends,\n  (select count(*) from q_stat_activity where waiting) AS blocked_backends,\n  (select round(extract(epoch from now()) - extract(epoch from (select xact_start from q_stat_activity\n    where datid = d.datid and not current_query like 'autovacuum:%' order by xact_start limit 1))))::int AS kpi_oldest_tx_s,\n  xact_commit + xact_rollback AS tps,\n  xact_commit,\n  xact_rollback,\n  blks_read,\n  blks_hit,\n  (select sum(seq_scan) from q_stat_tables)::int8 AS seq_scans_on_tbls_gt_10mb,\n  tup_inserted,\n  tup_updated,\n  tup_deleted,\n  (select sum(calls) from pg_stat_user_functions where not schemaname like any(array[E'pg\\\\_%', 'information_schema']))::int8 AS sproc_calls,\n  extract(epoch from (now() - pg_postmaster_start_time()))::int8 as postmaster_uptime_s\nFROM\n  pg_stat_database d\nWHERE\n  datname = current_database();\n
81	kpi	9.2	\nWITH q_stat_tables AS (\n  SELECT * FROM pg_stat_user_tables t\n  JOIN pg_class c ON c.oid = t.relid\n  WHERE NOT schemaname LIKE E'pg\\\\_temp%'\n  AND c.relpages > (1e7 / 8)    -- >10MB\n),\nq_stat_activity AS (\n  SELECT * FROM get_stat_activity()\n)\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  case\n      when pg_is_in_recovery() = false then\n          pg_xlog_location_diff(pg_current_xlog_location(), '0/0')::int8\n      else\n          pg_xlog_location_diff(pg_last_xlog_replay_location(), '0/0')::int8\n      end as wal_location_b,\n  numbackends - 1 as numbackends,\n  (select count(1) from q_stat_activity where state = 'active') AS active_backends,\n  (select count(1) from q_stat_activity where waiting) AS blocked_backends,\n  (select round(extract(epoch from now()) - extract(epoch from (select xact_start from q_stat_activity\n    where datid = d.datid and not query like 'autovacuum:%' order by xact_start limit 1))))::int AS kpi_oldest_tx_s,\n  xact_commit + xact_rollback AS tps,\n  xact_commit,\n  xact_rollback,\n  blks_read,\n  blks_hit,\n  temp_bytes,\n  (select sum(seq_scan) from q_stat_tables)::int8 AS seq_scans_on_tbls_gt_10mb,\n  tup_inserted,\n  tup_updated,\n  tup_deleted,\n  (select sum(calls) from pg_stat_user_functions where not schemaname like any(array[E'pg\\\\_%', 'information_schema']))::int8 AS sproc_calls,\n  blk_read_time,\n  blk_write_time,\n  deadlocks,\n  case when pg_is_in_recovery() then 1 else 0 end as in_recovery_int,\n  extract(epoch from (now() - pg_postmaster_start_time()))::int8 as postmaster_uptime_s\nFROM\n  pg_stat_database d\nWHERE\n  datname = current_database();\n	\N	t	f	2020-05-05 17:15:29.275456-07	f	f	{"prometheus_gauge_columns": ["numbackends", "active_backends", "blocked_backends", "kpi_oldest_tx_s"]}	\nWITH q_stat_tables AS (\n    SELECT * FROM pg_stat_user_tables t\n                      JOIN pg_class c ON c.oid = t.relid\n    WHERE NOT schemaname LIKE E'pg\\\\_temp%'\n      AND c.relpages > (1e7 / 8)    -- >10MB\n),\n     q_stat_activity AS (\n         SELECT * FROM pg_stat_activity\n         WHERE datname = current_database() AND pid != pg_backend_pid()\n     )\nSELECT\n    (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  case\n      when pg_is_in_recovery() = false then\n          pg_xlog_location_diff(pg_current_xlog_location(), '0/0')::int8\n      else\n          pg_xlog_location_diff(pg_last_xlog_replay_location(), '0/0')::int8\n      end as wal_location_b,\n    numbackends - 1 as numbackends,\n    (select count(1) from q_stat_activity where state = 'active') AS active_backends,\n    (select count(1) from q_stat_activity where waiting) AS blocked_backends,\n    (select round(extract(epoch from now()) - extract(epoch from (select xact_start from q_stat_activity\n                                                                  where datid = d.datid and not query like 'autovacuum:%' order by xact_start limit 1))))::int AS kpi_oldest_tx_s,\n    xact_commit + xact_rollback AS tps,\n    xact_commit,\n    xact_rollback,\n    blks_read,\n    blks_hit,\n    temp_bytes,\n    (select sum(seq_scan) from q_stat_tables)::int8 AS seq_scans_on_tbls_gt_10mb,\n    tup_inserted,\n    tup_updated,\n    tup_deleted,\n    (select sum(calls) from pg_stat_user_functions where not schemaname like any(array[E'pg\\\\_%', 'information_schema']))::int8 AS sproc_calls,\n    blk_read_time,\n    blk_write_time,\n    deadlocks,\n    case when pg_is_in_recovery() then 1 else 0 end as in_recovery_int,\n    extract(epoch from (now() - pg_postmaster_start_time()))::int8 as postmaster_uptime_s\nFROM\n    pg_stat_database d\nWHERE\n    datname = current_database();\n
82	kpi	9.6	\nWITH q_stat_tables AS (\n  SELECT * FROM pg_stat_user_tables t\n  JOIN pg_class c ON c.oid = t.relid\n  WHERE NOT schemaname LIKE E'pg\\\\_temp%'\n  AND c.relpages > (1e7 / 8)    -- >10MB\n),\nq_stat_activity AS (\n  SELECT * FROM get_stat_activity()\n)\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  case\n    when pg_is_in_recovery() = false then\n      pg_xlog_location_diff(pg_current_xlog_location(), '0/0')::int8\n    else\n      pg_xlog_location_diff(pg_last_xlog_replay_location(), '0/0')::int8\n    end as wal_location_b,\n  numbackends - 1 as numbackends,\n  (select count(1) from q_stat_activity where state = 'active') AS active_backends,\n  (select count(1) from q_stat_activity where wait_event_type is not null) AS blocked_backends,\n  (select round(extract(epoch from now()) - extract(epoch from (select xact_start from q_stat_activity\n    where datid = d.datid and not query like 'autovacuum:%' order by xact_start limit 1))))::int AS kpi_oldest_tx_s,\n  xact_commit + xact_rollback AS tps,\n  xact_commit,\n  xact_rollback,\n  blks_read,\n  blks_hit,\n  temp_bytes,\n  (select sum(seq_scan) from q_stat_tables)::int8 AS seq_scans_on_tbls_gt_10mb,\n  tup_inserted,\n  tup_updated,\n  tup_deleted,\n  (select sum(calls) from pg_stat_user_functions where not schemaname like any(array[E'pg\\\\_%', 'information_schema']))::int8 AS sproc_calls,\n  blk_read_time,\n  blk_write_time,\n  deadlocks,\n  case when pg_is_in_recovery() then 1 else 0 end as in_recovery_int,\n  extract(epoch from (now() - pg_postmaster_start_time()))::int8 as postmaster_uptime_s\nFROM\n  pg_stat_database d\nWHERE\n  datname = current_database();\n	\N	t	f	2020-05-05 17:15:29.276534-07	f	f	{"prometheus_gauge_columns": ["numbackends", "active_backends", "blocked_backends", "kpi_oldest_tx_s"]}	\nWITH q_stat_tables AS (\n  SELECT * FROM pg_stat_user_tables t\n  JOIN pg_class c ON c.oid = t.relid\n  WHERE NOT schemaname LIKE E'pg\\\\_temp%'\n  AND c.relpages > (1e7 / 8)    -- >10MB\n),\nq_stat_activity AS (\n    SELECT * FROM pg_stat_activity\n    WHERE datname = current_database() AND pid != pg_backend_pid()\n)\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  case\n    when pg_is_in_recovery() = false then\n      pg_xlog_location_diff(pg_current_xlog_location(), '0/0')::int8\n    else\n      pg_xlog_location_diff(pg_last_xlog_replay_location(), '0/0')::int8\n    end as xlog_location_b,\n  numbackends - 1 as numbackends,\n  (select count(*) from q_stat_activity where state in ('active', 'idle in transaction')) AS active_backends,\n  (select count(*) from q_stat_activity where wait_event_type in ('LWLockNamed', 'Lock', 'BufferPin')) AS blocked_backends,\n  (select round(extract(epoch from now()) - extract(epoch from (select xact_start from q_stat_activity\n    where datid = d.datid and not query like 'autovacuum:%' order by xact_start limit 1))))::int AS kpi_oldest_tx_s,\n  xact_commit + xact_rollback AS tps,\n  xact_commit,\n  xact_rollback,\n  blks_read,\n  blks_hit,\n  temp_bytes,\n  (select sum(seq_scan) from q_stat_tables)::int8 AS seq_scans_on_tbls_gt_10mb,\n  tup_inserted,\n  tup_updated,\n  tup_deleted,\n  (select sum(calls) from pg_stat_user_functions where not schemaname like any(array[E'pg\\\\_%', 'information_schema']))::int8 AS sproc_calls,\n  blk_read_time,\n  blk_write_time,\n  deadlocks,\n  case when pg_is_in_recovery() then 1 else 0 end as in_recovery_int,\n  extract(epoch from (now() - pg_postmaster_start_time()))::int8 as postmaster_uptime_s\nFROM\n  pg_stat_database d\nWHERE\n  datname = current_database();\n
83	kpi	10	\nWITH q_stat_tables AS (\n  SELECT * FROM pg_stat_user_tables t\n  JOIN pg_class c ON c.oid = t.relid\n  WHERE NOT schemaname LIKE E'pg\\\\_temp%'\n  AND c.relpages > (1e7 / 8)    -- >10MB\n),\nq_stat_activity AS (\n  SELECT * FROM get_stat_activity()\n)\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  case\n      when pg_is_in_recovery() = false then\n          pg_wal_lsn_diff(pg_current_wal_lsn(), '0/0')::int8\n      else\n          pg_wal_lsn_diff(pg_last_wal_replay_lsn(), '0/0')::int8\n      end as wal_location_b,\n  numbackends - 1 as numbackends,\n  (select count(1) from q_stat_activity where state = 'active') AS active_backends,\n  (select count(1) from q_stat_activity where wait_event_type is not null) AS blocked_backends,\n  (select round(extract(epoch from now()) - extract(epoch from (select xact_start from q_stat_activity\n    where datid = d.datid and not query like 'autovacuum:%' order by xact_start limit 1))))::int AS kpi_oldest_tx_s,\n  xact_commit + xact_rollback AS tps,\n  xact_commit,\n  xact_rollback,\n  blks_read,\n  blks_hit,\n  temp_bytes,\n  (select sum(seq_scan) from q_stat_tables)::int8 AS seq_scans_on_tbls_gt_10mb,\n  tup_inserted,\n  tup_updated,\n  tup_deleted,\n  (select sum(calls) from pg_stat_user_functions where not schemaname like any(array[E'pg\\\\_%', 'information_schema']))::int8 AS sproc_calls,\n  blk_read_time,\n  blk_write_time,\n  deadlocks,\n  case when pg_is_in_recovery() then 1 else 0 end as in_recovery_int,\n  extract(epoch from (now() - pg_postmaster_start_time()))::int8 as postmaster_uptime_s\nFROM\n  pg_stat_database d\nWHERE\n  datname = current_database();\n	\N	t	f	2020-05-05 17:15:29.277374-07	f	f	{"prometheus_gauge_columns": ["numbackends", "active_backends", "blocked_backends", "kpi_oldest_tx_s"]}	\nWITH q_stat_tables AS (\n  SELECT * FROM pg_stat_user_tables t\n  JOIN pg_class c ON c.oid = t.relid\n  WHERE NOT schemaname LIKE E'pg\\\\_temp%'\n  AND c.relpages > (1e7 / 8)    -- >10MB\n),\nq_stat_activity AS (\n    SELECT * FROM pg_stat_activity\n    WHERE datname = current_database() AND pid != pg_backend_pid()\n)\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  case\n      when pg_is_in_recovery() = false then\n          pg_wal_lsn_diff(pg_current_wal_lsn(), '0/0')::int8\n      else\n          pg_wal_lsn_diff(pg_last_wal_replay_lsn(), '0/0')::int8\n      end as wal_location_b,\n  numbackends - 1 as numbackends,\n  (select count(*) from q_stat_activity where state in ('active', 'idle in transaction')) AS active_backends,\n  (select count(*) from q_stat_activity where wait_event_type in ('LWLock', 'Lock', 'BufferPin')) AS blocked_backends,\n  (select round(extract(epoch from now()) - extract(epoch from (select xact_start from q_stat_activity\n    where datid = d.datid and not query like 'autovacuum:%' order by xact_start limit 1))))::int AS kpi_oldest_tx_s,\n  xact_commit + xact_rollback AS tps,\n  xact_commit,\n  xact_rollback,\n  blks_read,\n  blks_hit,\n  temp_bytes,\n  (select sum(seq_scan) from q_stat_tables)::int8 AS seq_scans_on_tbls_gt_10mb,\n  tup_inserted,\n  tup_updated,\n  tup_deleted,\n  (select sum(calls) from pg_stat_user_functions where not schemaname like any(array[E'pg\\\\_%', 'information_schema']))::int8 AS sproc_calls,\n  blk_read_time,\n  blk_write_time,\n  deadlocks,\n  case when pg_is_in_recovery() then 1 else 0 end as in_recovery_int,\n  extract(epoch from (now() - pg_postmaster_start_time()))::int8 as postmaster_uptime_s\nFROM\n  pg_stat_database d\nWHERE\n  datname = current_database();\n
84	replication	9.2	\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  application_name as tag_application_name,\n  concat(coalesce(client_addr::text, client_hostname), '_', client_port::text) as tag_client_info,\n  coalesce(pg_xlog_location_diff(pg_current_xlog_location(), write_location)::int8, 0) as write_lag_b,\n  coalesce(pg_xlog_location_diff(pg_current_xlog_location(), flush_location)::int8, 0) as flush_lag_b,\n  coalesce(pg_xlog_location_diff(pg_current_xlog_location(), replay_location)::int8, 0) as replay_lag_b,\n  state,\n  sync_state,\n  case when sync_state in ('sync', 'quorum') then 1 else 0 end as is_sync_int\nfrom\n  get_stat_replication();\n	\N	t	f	2020-05-05 17:15:29.278059-07	t	f	{"prometheus_all_gauge_columns": true}	\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  application_name as tag_application_name,\n  concat(coalesce(client_addr::text, client_hostname), '_', client_port::text) as tag_client_info,\n  coalesce(pg_xlog_location_diff(pg_current_xlog_location(), write_location)::int8, 0) as write_lag_b,\n  coalesce(pg_xlog_location_diff(pg_current_xlog_location(), flush_location)::int8, 0) as flush_lag_b,\n  coalesce(pg_xlog_location_diff(pg_current_xlog_location(), replay_location)::int8, 0) as replay_lag_b,\n  state,\n  sync_state,\n  case when sync_state in ('sync', 'quorum') then 1 else 0 end as is_sync_int\nfrom\n  pg_stat_replication\n
85	replication	10	\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  application_name as tag_application_name,\n  concat(coalesce(client_addr::text, client_hostname), '_', client_port::text) as tag_client_info,\n  coalesce(pg_wal_lsn_diff(pg_current_wal_lsn(), write_lsn)::int8, 0) as write_lag_b,\n  coalesce(pg_wal_lsn_diff(pg_current_wal_lsn(), flush_lsn)::int8, 0) as flush_lag_b,\n  coalesce(pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn)::int8, 0) as replay_lag_b,\n  state,\n  sync_state,\n  case when sync_state in ('sync', 'quorum') then 1 else 0 end as is_sync_int\nfrom\n  /* NB! when the query fails, grant "pg_monitor" system role (exposing all stats) to the monitoring user\n     or create specifically the "get_stat_replication" helper and use that instead of pg_stat_replication\n  */\n  pg_stat_replication;\n	\N	t	f	2020-05-05 17:15:29.278646-07	t	f	{"prometheus_all_gauge_columns": true}	
87	table_io_stats	9.0	\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  schemaname::text as tag_schema,\n  relname::text as tag_table_name,\n  quote_ident(schemaname)||'.'||quote_ident(relname) as tag_table_full_name,\n  heap_blks_read,\n  heap_blks_hit,\n  idx_blks_read,\n  idx_blks_hit,\n  toast_blks_read,\n  toast_blks_hit,\n  tidx_blks_read,\n  tidx_blks_hit\nFROM\n  pg_statio_user_tables\nWHERE\n  NOT schemaname LIKE E'pg\\\\_temp%'\n  AND (heap_blks_read > 0 OR heap_blks_hit > 0 OR idx_blks_read > 0 OR idx_blks_hit > 0 OR tidx_blks_read > 0 OR tidx_blks_hit > 0);\n	\N	t	f	2020-05-05 17:15:29.279693-07	f	f	\N	
88	table_stats	9.0	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  quote_ident(schemaname) as tag_schema,\n  quote_ident(ut.relname) as tag_table_name,\n  quote_ident(schemaname)||'.'||quote_ident(ut.relname) as tag_table_full_name,\n  pg_table_size(relid) as table_size_b,\n  abs(greatest(ceil(log((pg_table_size(relid)+1) / 10^6)), 0))::text as tag_table_size_cardinality_mb, -- i.e. 0=<1MB, 1=<10MB, 2=<100MB,..\n  pg_total_relation_size(relid) as total_relation_size_b,\n  case when reltoastrelid != 0 then pg_total_relation_size(reltoastrelid) else 0::int8 end as toast_size_b,\n  (extract(epoch from now() - greatest(last_vacuum, last_autovacuum)))::int8 as seconds_since_last_vacuum,\n  (extract(epoch from now() - greatest(last_analyze, last_autoanalyze)))::int8 as seconds_since_last_analyze,\n  case when 'autovacuum_enabled=off' = ANY(c.reloptions) then 1 else 0 end as no_autovacuum,\n  seq_scan,\n  seq_tup_read,\n  idx_scan,\n  idx_tup_fetch,\n  n_tup_ins,\n  n_tup_upd,\n  n_tup_del,\n  n_tup_hot_upd,\n  n_live_tup,\n  n_dead_tup,\n  age(relfrozenxid) as tx_freeze_age\nfrom\n  pg_stat_user_tables ut\n  join\n  pg_class c on c.oid = ut.relid\nwhere\n  -- leaving out fully locked tables as pg_relation_size also wants a lock and would wait\n  not exists (select 1 from pg_locks where relation = relid and mode = 'AccessExclusiveLock' and granted)\n  and not relistemp; -- and temp tables\n	\N	t	f	2020-05-05 17:15:29.280246-07	t	f	{"prometheus_gauge_columns": ["table_size_b", "total_relation_size_b", "toast_size_b", "seconds_since_last_vacuum", "seconds_since_last_analyze", "n_live_tup", "n_dead_tup"]}	
89	table_stats	9.0	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  quote_ident(schemaname) as tag_schema,\n  quote_ident(ut.relname) as tag_table_name,\n  quote_ident(schemaname)||'.'||quote_ident(ut.relname) as tag_table_full_name,\n  pg_table_size(relid) as table_size_b,\n  abs(greatest(ceil(log((pg_table_size(relid)+1) / 10^6)), 0))::text as tag_table_size_cardinality_mb, -- i.e. 0=<1MB, 1=<10MB, 2=<100MB,..\n  pg_total_relation_size(relid) as total_relation_size_b,\n  case when reltoastrelid != 0 then pg_total_relation_size(reltoastrelid) else 0::int8 end as toast_size_b,\n  (extract(epoch from now() - greatest(last_vacuum, last_autovacuum)))::int8 as seconds_since_last_vacuum,\n  (extract(epoch from now() - greatest(last_analyze, last_autoanalyze)))::int8 as seconds_since_last_analyze,\n  case when 'autovacuum_enabled=off' = ANY(c.reloptions) then 1 else 0 end as no_autovacuum,\n  seq_scan,\n  seq_tup_read,\n  idx_scan,\n  idx_tup_fetch,\n  n_tup_ins,\n  n_tup_upd,\n  n_tup_del,\n  n_tup_hot_upd,\n  n_live_tup,\n  n_dead_tup\nfrom\n  pg_stat_user_tables ut\n  join\n  pg_class c on c.oid = ut.relid\nwhere\n  -- leaving out fully locked tables as pg_relation_size also wants a lock and would wait\n  not exists (select 1 from pg_locks where relation = relid and mode = 'AccessExclusiveLock' and granted)\n  and not relistemp; -- and temp tables\n	\N	t	f	2020-05-05 17:15:29.280831-07	f	t	{"prometheus_gauge_columns": ["table_size_b", "total_relation_size_b", "toast_size_b", "seconds_since_last_vacuum", "seconds_since_last_analyze", "n_live_tup", "n_dead_tup"]}	
90	table_stats	9.1	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  quote_ident(schemaname) as tag_schema,\n  quote_ident(ut.relname) as tag_table_name,\n  quote_ident(schemaname)||'.'||quote_ident(ut.relname) as tag_table_full_name,\n  pg_table_size(relid) as table_size_b,\n  abs(greatest(ceil(log((pg_table_size(relid)+1) / 10^6)), 0))::text as tag_table_size_cardinality_mb, -- i.e. 0=<1MB, 1=<10MB, 2=<100MB,..\n  pg_total_relation_size(relid) as total_relation_size_b,\n  case when reltoastrelid != 0 then pg_total_relation_size(reltoastrelid) else 0::int8 end as toast_size_b,\n  (extract(epoch from now() - greatest(last_vacuum, last_autovacuum)))::int8 as seconds_since_last_vacuum,\n  (extract(epoch from now() - greatest(last_analyze, last_autoanalyze)))::int8 as seconds_since_last_analyze,\n  case when 'autovacuum_enabled=off' = ANY(c.reloptions) then 1 else 0 end as no_autovacuum,\n  seq_scan,\n  seq_tup_read,\n  idx_scan,\n  idx_tup_fetch,\n  n_tup_ins,\n  n_tup_upd,\n  n_tup_del,\n  n_tup_hot_upd,\n  n_live_tup,\n  n_dead_tup,\n  vacuum_count,\n  autovacuum_count,\n  analyze_count,\n  autoanalyze_count,\n  age(relfrozenxid) as tx_freeze_age\nfrom\n  pg_stat_user_tables ut\n  join\n  pg_class c on c.oid = ut.relid\nwhere\n  -- leaving out fully locked tables as pg_relation_size also wants a lock and would wait\n  not exists (select 1 from pg_locks where relation = relid and mode = 'AccessExclusiveLock' and granted)\n  and c.relpersistence != 't'; -- and temp tables\n	\N	t	f	2020-05-05 17:15:29.28137-07	t	f	{"prometheus_gauge_columns": ["table_size_b", "total_relation_size_b", "toast_size_b", "seconds_since_last_vacuum", "seconds_since_last_analyze", "n_live_tup", "n_dead_tup"]}	
91	table_stats	9.1	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  quote_ident(schemaname) as tag_schema,\n  quote_ident(ut.relname) as tag_table_name,\n  quote_ident(schemaname)||'.'||quote_ident(ut.relname) as tag_table_full_name,\n  pg_table_size(relid) as table_size_b,\n  abs(greatest(ceil(log((pg_table_size(relid)+1) / 10^6)), 0))::text as tag_table_size_cardinality_mb, -- i.e. 0=<1MB, 1=<10MB, 2=<100MB,..\n  pg_total_relation_size(relid) as total_relation_size_b,\n  case when reltoastrelid != 0 then pg_total_relation_size(reltoastrelid) else 0::int8 end as toast_size_b,\n  (extract(epoch from now() - greatest(last_vacuum, last_autovacuum)))::int8 as seconds_since_last_vacuum,\n  (extract(epoch from now() - greatest(last_analyze, last_autoanalyze)))::int8 as seconds_since_last_analyze,\n  case when 'autovacuum_enabled=off' = ANY(c.reloptions) then 1 else 0 end as no_autovacuum,\n  seq_scan,\n  seq_tup_read,\n  idx_scan,\n  idx_tup_fetch,\n  n_tup_ins,\n  n_tup_upd,\n  n_tup_del,\n  n_tup_hot_upd,\n  n_live_tup,\n  n_dead_tup,\n  vacuum_count,\n  autovacuum_count,\n  analyze_count,\n  autoanalyze_count,\n  age(relfrozenxid) as tx_freeze_age\nfrom\n  pg_stat_user_tables ut\n  join\n  pg_class c on c.oid = ut.relid\nwhere\n  -- leaving out fully locked tables as pg_relation_size also wants a lock and would wait\n  not exists (select 1 from pg_locks where relation = relid and mode = 'AccessExclusiveLock' and granted)\n  and c.relpersistence != 't'; -- and temp tables\n	\N	t	f	2020-05-05 17:15:29.281858-07	f	t	{"prometheus_gauge_columns": ["table_size_b", "total_relation_size_b", "toast_size_b", "seconds_since_last_vacuum", "seconds_since_last_analyze", "n_live_tup", "n_dead_tup"]}	
114	table_bloat_approx_summary_sql	12	\nWITH q_bloat AS (\n    select * from get_table_bloat_approx_sql()\n)\nSELECT\n    (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n    (select sum(approx_bloat_bytes) from q_bloat) as approx_table_bloat_b,\n    ((select sum(approx_bloat_bytes) from q_bloat) * 100 / pg_database_size(current_database()))::int8 as approx_bloat_percentage\n;\n	\N	t	f	2020-05-05 17:15:29.297475-07	t	f	{"prometheus_all_gauge_columns": true}	\nWITH q_bloat AS (\n    SELECT quote_ident(schemaname) || '.' || quote_ident(tblname) as full_table_name,\n           bloat_ratio                                            as approx_bloat_percent,\n           bloat_size                                             as approx_bloat_bytes,\n           fillfactor\n    FROM (\n\n/* WARNING: executed with a non-superuser role, the query inspect only tables you are granted to read.\n* This query is compatible with PostgreSQL 9.0 and more\n*/\n             SELECT current_database(),\n                    schemaname,\n                    tblname,\n                    bs * tblpages                  AS real_size,\n                    (tblpages - est_tblpages) * bs AS extra_size,\n                    CASE\n                        WHEN tblpages - est_tblpages > 0\n                            THEN 100 * (tblpages - est_tblpages) / tblpages::float\n                        ELSE 0\n                        END                        AS extra_ratio,\n                    fillfactor,\n                    CASE\n                        WHEN tblpages - est_tblpages_ff > 0\n                            THEN (tblpages - est_tblpages_ff) * bs\n                        ELSE 0\n                        END                        AS bloat_size,\n                    CASE\n                        WHEN tblpages - est_tblpages_ff > 0\n                            THEN 100 * (tblpages - est_tblpages_ff) / tblpages::float\n                        ELSE 0\n                        END                        AS bloat_ratio,\n                    is_na\n                    -- , (pst).free_percent + (pst).dead_tuple_percent AS real_frag\n             FROM (\n                      SELECT ceil(reltuples / ((bs - page_hdr) / tpl_size)) + ceil(toasttuples / 4) AS est_tblpages,\n                             ceil(reltuples / ((bs - page_hdr) * fillfactor / (tpl_size * 100))) +\n                             ceil(toasttuples / 4)                                                  AS est_tblpages_ff,\n                             tblpages,\n                             fillfactor,\n                             bs,\n                             tblid,\n                             schemaname,\n                             tblname,\n                             heappages,\n                             toastpages,\n                             is_na\n                             -- , stattuple.pgstattuple(tblid) AS pst\n                      FROM (\n                               SELECT (4 + tpl_hdr_size + tpl_data_size + (2 * ma)\n                                   - CASE WHEN tpl_hdr_size % ma = 0 THEN ma ELSE tpl_hdr_size % ma END\n                                   - CASE\n                                         WHEN ceil(tpl_data_size)::int % ma = 0 THEN ma\n                                         ELSE ceil(tpl_data_size)::int % ma END\n                                          )                    AS tpl_size,\n                                      bs - page_hdr            AS size_per_block,\n                                      (heappages + toastpages) AS tblpages,\n                                      heappages,\n                                      toastpages,\n                                      reltuples,\n                                      toasttuples,\n                                      bs,\n                                      page_hdr,\n                                      tblid,\n                                      schemaname,\n                                      tblname,\n                                      fillfactor,\n                                      is_na\n                               FROM (\n                                        SELECT tbl.oid                                                           AS tblid,\n                                               ns.nspname                                                        AS schemaname,\n                                               tbl.relname                                                       AS tblname,\n                                               tbl.reltuples,\n                                               tbl.relpages                                                      AS heappages,\n                                               coalesce(toast.relpages, 0)                                       AS toastpages,\n                                               coalesce(toast.reltuples, 0)                                      AS toasttuples,\n                                               coalesce(substring(\n                                                                array_to_string(tbl.reloptions, ' ')\n                                                                FROM 'fillfactor=([0-9]+)')::smallint,\n                                                        100)                                                     AS fillfactor,\n                                               current_setting('block_size')::numeric                            AS bs,\n                                               CASE\n                                                   WHEN version() ~ 'mingw32' OR version() ~ '64-bit|x86_64|ppc64|ia64|amd64'\n                                                       THEN 8\n                                                   ELSE 4 END                                                    AS ma,\n                                               24                                                                AS page_hdr,\n                                               23 + CASE\n                                                        WHEN MAX(coalesce(null_frac, 0)) > 0 THEN (7 + count(*)) / 8\n                                                        ELSE 0::int END\n                                                   +\n                                               0                                                                 AS tpl_hdr_size,\n                                               sum((1 - coalesce(s.null_frac, 0)) * coalesce(s.avg_width, 1024)) AS tpl_data_size,\n                                               bool_or(att.atttypid = 'pg_catalog.name'::regtype)\n                                                   OR\n                                               count(att.attname) <> count(s.attname)                            AS is_na\n                                        FROM pg_attribute AS att\n                                                 JOIN pg_class AS tbl ON att.attrelid = tbl.oid\n                                                 JOIN pg_namespace AS ns ON ns.oid = tbl.relnamespace\n                                                 LEFT JOIN pg_stats AS s ON s.schemaname = ns.nspname\n                                            AND s.tablename = tbl.relname AND s.inherited = false AND\n                                                                            s.attname = att.attname\n                                                 LEFT JOIN pg_class AS toast ON tbl.reltoastrelid = toast.oid\n                                        WHERE att.attnum > 0\n                                          AND NOT att.attisdropped\n                                          AND tbl.relkind IN ('r', 'm')\n                                          AND ns.nspname != 'information_schema'\n                                        GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n                                        ORDER BY 2, 3\n                                    ) AS s\n                           ) AS s2\n                  ) AS s3\n             -- WHERE NOT is_na\n         ) s4\n)\nSELECT\n    (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n    (select sum(approx_bloat_bytes) from q_bloat) as approx_table_bloat_b,\n    ((select sum(approx_bloat_bytes) from q_bloat) * 100 / pg_database_size(current_database()))::int8 as approx_bloat_percentage;\n
115	change_events	9.0	\n	\N	t	f	2020-05-05 17:15:29.298503-07	f	f	\N	
92	table_stats	9.2	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  quote_ident(schemaname) as tag_schema,\n  quote_ident(ut.relname) as tag_table_name,\n  quote_ident(schemaname)||'.'||quote_ident(ut.relname) as tag_table_full_name,\n  pg_table_size(relid) as table_size_b,\n  abs(greatest(ceil(log((pg_table_size(relid)+1) / 10^6)), 0))::text as tag_table_size_cardinality_mb, -- i.e. 0=<1MB, 1=<10MB, 2=<100MB,..\n  pg_total_relation_size(relid) as total_relation_size_b,\n  case when reltoastrelid != 0 then pg_total_relation_size(reltoastrelid) else 0::int8 end as toast_size_b,\n  (extract(epoch from now() - greatest(last_vacuum, last_autovacuum)))::int8 as seconds_since_last_vacuum,\n  (extract(epoch from now() - greatest(last_analyze, last_autoanalyze)))::int8 as seconds_since_last_analyze,\n  case when 'autovacuum_enabled=off' = ANY(c.reloptions) then 1 else 0 end as no_autovacuum,\n  seq_scan,\n  seq_tup_read,\n  idx_scan,\n  idx_tup_fetch,\n  n_tup_ins,\n  n_tup_upd,\n  n_tup_del,\n  n_tup_hot_upd,\n  n_live_tup,\n  n_dead_tup,\n  vacuum_count,\n  autovacuum_count,\n  analyze_count,\n  autoanalyze_count,\n  age(relfrozenxid) as tx_freeze_age\nfrom\n  pg_stat_user_tables ut\n  join\n  pg_class c on c.oid = ut.relid\nwhere\n  -- leaving out fully locked tables as pg_relation_size also wants a lock and would wait\n  not exists (select 1 from pg_locks where relation = relid and mode = 'AccessExclusiveLock' and granted)\n  and c.relpersistence != 't'; -- and temp tables\n	\N	t	f	2020-05-05 17:15:29.282366-07	f	f	{"prometheus_gauge_columns": ["table_size_b", "total_relation_size_b", "toast_size_b", "seconds_since_last_vacuum", "seconds_since_last_analyze", "n_live_tup", "n_dead_tup"]}	
93	wal	9.2	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  case\n    when pg_is_in_recovery() = false then\n      pg_xlog_location_diff(pg_current_xlog_location(), '0/0')::int8\n    else\n      pg_xlog_location_diff(pg_last_xlog_replay_location(), '0/0')::int8\n    end as xlog_location_b,\n  case when pg_is_in_recovery() then 1 else 0 end as in_recovery_int,\n  extract(epoch from (now() - pg_postmaster_start_time()))::int8 as postmaster_uptime_s;\n	\N	t	f	2020-05-05 17:15:29.282861-07	f	f	{"prometheus_gauge_columns": ["in_recovery_int", "postmaster_uptime_s"]}	
94	wal	10	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  case\n    when pg_is_in_recovery() = false then\n      pg_wal_lsn_diff(pg_current_wal_lsn(), '0/0')::int8\n    else\n      pg_wal_lsn_diff(pg_last_wal_replay_lsn(), '0/0')::int8\n    end as xlog_location_b,\n  case when pg_is_in_recovery() then 1 else 0 end as in_recovery_int,\n  extract(epoch from (now() - pg_postmaster_start_time()))::int8 as postmaster_uptime_s,\n  system_identifier::text as tag_sys_id\nfrom pg_control_system();\n	\N	t	f	2020-05-05 17:15:29.283287-07	f	f	{"prometheus_gauge_columns": ["in_recovery_int", "postmaster_uptime_s"]}	
95	stat_statements	9.2	\nwith q_data as (\n  select\n    (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n    (regexp_replace(md5(query), E'\\\\D', '', 'g'))::varchar(10)::int8 as tag_queryid,\n    max(ltrim(regexp_replace(query, E'[ \\\\t\\\\n\\\\r]+' , ' ', 'g')))::varchar(16000) as tag_query,\n    array_to_string(array_agg(distinct quote_ident(pg_get_userbyid(userid))), ',') as users,\n    sum(s.calls)::int8 as calls,\n    round(sum(s.total_time)::numeric, 3)::double precision as total_time,\n    sum(shared_blks_hit)::int8 as shared_blks_hit,\n    sum(shared_blks_read)::int8 as shared_blks_read,\n    sum(shared_blks_written)::int8 as shared_blks_written,\n    sum(shared_blks_dirtied)::int8 as shared_blks_dirtied,\n    sum(temp_blks_read)::int8 as temp_blks_read,\n    sum(temp_blks_written)::int8 as temp_blks_written,\n    round(sum(blk_read_time)::numeric, 3)::double precision as blk_read_time,\n    round(sum(blk_write_time)::numeric, 3)::double precision as blk_write_time\n  from\n    get_stat_statements() s\n  where\n    calls > 5\n    and total_time > 0\n    and dbid = (select oid from pg_database where datname = current_database())\n    and not upper(s.query) like any (array['DEALLOCATE%', 'SET %', 'RESET %', 'BEGIN%', 'BEGIN;',\n      'COMMIT%', 'END%', 'ROLLBACK%', 'SHOW%'])\n  group by\n    tag_queryid\n)\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    total_time > 0\n  order by\n    total_time desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  order by\n    calls desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    shared_blks_read > 0\n  order by\n    shared_blks_read desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    shared_blks_written > 0\n  order by\n    shared_blks_written desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    temp_blks_read > 0\n  order by\n    temp_blks_read desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    temp_blks_written > 0\n  order by\n    temp_blks_written desc\n  limit 100\n) a;\n	\N	t	f	2020-05-05 17:15:29.284042-07	f	f	\N	\nwith q_data as (\n  select\n    (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n    (regexp_replace(md5(query), E'\\\\D', '', 'g'))::varchar(10)::int8 as tag_queryid,\n    max(ltrim(regexp_replace(query, E'[ \\\\t\\\\n\\\\r]+' , ' ', 'g')))::varchar(16000) as tag_query,\n    array_to_string(array_agg(distinct quote_ident(pg_get_userbyid(userid))), ',') as users,\n    sum(s.calls)::int8 as calls,\n    round(sum(s.total_time)::numeric, 3)::double precision as total_time,\n    sum(shared_blks_hit)::int8 as shared_blks_hit,\n    sum(shared_blks_read)::int8 as shared_blks_read,\n    sum(shared_blks_written)::int8 as shared_blks_written,\n    sum(shared_blks_dirtied)::int8 as shared_blks_dirtied,\n    sum(temp_blks_read)::int8 as temp_blks_read,\n    sum(temp_blks_written)::int8 as temp_blks_written,\n    round(sum(blk_read_time)::numeric, 3)::double precision as blk_read_time,\n    round(sum(blk_write_time)::numeric, 3)::double precision as blk_write_time\n  from\n    pg_stat_statements s\n  where\n    calls > 5\n    and total_time > 0\n    and dbid = (select oid from pg_database where datname = current_database())\n    and not upper(s.query) like any (array['DEALLOCATE%', 'SET %', 'RESET %', 'BEGIN%', 'BEGIN;',\n      'COMMIT%', 'END%', 'ROLLBACK%', 'SHOW%'])\n  group by\n    tag_queryid\n)\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    total_time > 0\n  order by\n    total_time desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  order by\n    calls desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    shared_blks_read > 0\n  order by\n    shared_blks_read desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    shared_blks_written > 0\n  order by\n    shared_blks_written desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    temp_blks_read > 0\n  order by\n    temp_blks_read desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    temp_blks_written > 0\n  order by\n    temp_blks_written desc\n  limit 100\n) a;\n
96	stat_statements	9.4	\nwith q_data as (\n  select\n    (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n    queryid::text as tag_queryid,\n    max(ltrim(regexp_replace(query, E'[ \\\\t\\\\n\\\\r]+' , ' ', 'g')))::varchar(16000) as tag_query,\n    array_to_string(array_agg(distinct quote_ident(pg_get_userbyid(userid))), ',') as users,\n    sum(s.calls)::int8 as calls,\n    round(sum(s.total_time)::numeric, 3)::double precision as total_time,\n    sum(shared_blks_hit)::int8 as shared_blks_hit,\n    sum(shared_blks_read)::int8 as shared_blks_read,\n    sum(shared_blks_written)::int8 as shared_blks_written,\n    sum(shared_blks_dirtied)::int8 as shared_blks_dirtied,\n    sum(temp_blks_read)::int8 as temp_blks_read,\n    sum(temp_blks_written)::int8 as temp_blks_written,\n    round(sum(blk_read_time)::numeric, 3)::double precision as blk_read_time,\n    round(sum(blk_write_time)::numeric, 3)::double precision as blk_write_time\n  from\n    get_stat_statements() s\n  where\n    calls > 5\n    and total_time > 0\n    and dbid = (select oid from pg_database where datname = current_database())\n    and not upper(s.query) like any (array['DEALLOCATE%', 'SET %', 'RESET %', 'BEGIN%', 'BEGIN;',\n      'COMMIT%', 'END%', 'ROLLBACK%', 'SHOW%'])\n  group by\n    queryid\n)\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    total_time > 0\n  order by\n    total_time desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  order by\n    calls desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    shared_blks_read > 0\n  order by\n    shared_blks_read desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    shared_blks_written > 0\n  order by\n    shared_blks_written desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    temp_blks_read > 0\n  order by\n    temp_blks_read desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    temp_blks_written > 0\n  order by\n    temp_blks_written desc\n  limit 100\n) a;\n	\N	t	f	2020-05-05 17:15:29.285033-07	f	f	\N	\nwith q_data as (\n  select\n    (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n    queryid::text as tag_queryid,\n    max(ltrim(regexp_replace(query, E'[ \\\\t\\\\n\\\\r]+' , ' ', 'g')))::varchar(16000) as tag_query,\n    array_to_string(array_agg(distinct quote_ident(pg_get_userbyid(userid))), ',') as users,\n    sum(s.calls)::int8 as calls,\n    round(sum(s.total_time)::numeric, 3)::double precision as total_time,\n    sum(shared_blks_hit)::int8 as shared_blks_hit,\n    sum(shared_blks_read)::int8 as shared_blks_read,\n    sum(shared_blks_written)::int8 as shared_blks_written,\n    sum(shared_blks_dirtied)::int8 as shared_blks_dirtied,\n    sum(temp_blks_read)::int8 as temp_blks_read,\n    sum(temp_blks_written)::int8 as temp_blks_written,\n    round(sum(blk_read_time)::numeric, 3)::double precision as blk_read_time,\n    round(sum(blk_write_time)::numeric, 3)::double precision as blk_write_time\n  from\n    pg_stat_statements s\n  where\n    calls > 5\n    and total_time > 0\n    and dbid = (select oid from pg_database where datname = current_database())\n    and not upper(s.query) like any (array['DEALLOCATE%', 'SET %', 'RESET %', 'BEGIN%', 'BEGIN;',\n      'COMMIT%', 'END%', 'ROLLBACK%', 'SHOW%'])\n  group by\n    queryid\n)\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    total_time > 0\n  order by\n    total_time desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  order by\n    calls desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    shared_blks_read > 0\n  order by\n    shared_blks_read desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    shared_blks_written > 0\n  order by\n    shared_blks_written desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    temp_blks_read > 0\n  order by\n    temp_blks_read desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    temp_blks_written > 0\n  order by\n    temp_blks_written desc\n  limit 100\n) a;\n
116	sproc_hashes	9.0	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  p.oid::text as tag_oid,\n  quote_ident(nspname)||'.'||quote_ident(proname) as tag_sproc,\n  md5(prosrc)\nfrom\n  pg_proc p\n  join\n  pg_namespace n on n.oid = pronamespace\nwhere\n  not nspname like any(array[E'pg\\\\_%', 'information_schema']);\n	\N	t	f	2020-05-05 17:15:29.298965-07	f	f	\N	
147	stat_activity_realtime	9.0	\nSELECT\n    (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n    pid as tag_pid,\n    usename::text AS user,\n    application_name AS appname,\n    coalesce(client_addr::text, 'local') AS ip,\n    extract(epoch FROM (now() - query_start))::int AS duration_s,\n    waiting::int,\n    case when sa.waiting then\n             (select array_to_string((select array_agg(distinct b.pid order by b.pid) from pg_locks b join pg_locks l on l.database = b.database and l.relation = b.relation\n                                      where l.pid = sa.procpid and b.pid != l.pid and b.granted and not l.granted), ','))\n         else\n             null\n        end as blocking_pids,\n    ltrim(regexp_replace(current_query, E'[ \\\\t\\\\n\\\\r]+' , ' ', 'g'))::varchar(300) AS query\nFROM\n    pg_stat_activity sa\nWHERE\n    current_query <> '<IDLE>'\n    AND procpid != pg_backend_pid()\n    AND datname = current_database()\n    AND NOW() - query_start > '500ms'::interval\nORDER BY\n    NOW() - query_start DESC\nLIMIT 25;\n	\N	t	f	2020-05-05 17:15:29.316105-07	f	f	{"prometheus_all_gauge_columns": true}	
97	stat_statements_no_query_text	9.2	\nwith q_data as (\n  select\n    (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n    (regexp_replace(md5(query), E'\\\\D', '', 'g'))::varchar(10)::int8 as tag_queryid,\n    '-' as tag_query,\n    array_to_string(array_agg(distinct quote_ident(pg_get_userbyid(userid))), ',') as users,\n    sum(s.calls)::int8 as calls,\n    round(sum(s.total_time)::numeric, 3)::double precision as total_time,\n    sum(shared_blks_hit)::int8 as shared_blks_hit,\n    sum(shared_blks_read)::int8 as shared_blks_read,\n    sum(shared_blks_written)::int8 as shared_blks_written,\n    sum(shared_blks_dirtied)::int8 as shared_blks_dirtied,\n    sum(temp_blks_read)::int8 as temp_blks_read,\n    sum(temp_blks_written)::int8 as temp_blks_written,\n    round(sum(blk_read_time)::numeric, 3)::double precision as blk_read_time,\n    round(sum(blk_write_time)::numeric, 3)::double precision as blk_write_time\n  from\n    get_stat_statements() s\n  where\n    calls > 5\n    and total_time > 0\n    and dbid = (select oid from pg_database where datname = current_database())\n    and not upper(s.query) like any (array['DEALLOCATE%', 'SET %', 'RESET %', 'BEGIN%', 'BEGIN;',\n      'COMMIT%', 'END%', 'ROLLBACK%', 'SHOW%'])\n  group by\n    tag_queryid\n)\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    total_time > 0\n  order by\n    total_time desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  order by\n    calls desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    shared_blks_read > 0\n  order by\n    shared_blks_read desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    shared_blks_written > 0\n  order by\n    shared_blks_written desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    temp_blks_read > 0\n  order by\n    temp_blks_read desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    temp_blks_written > 0\n  order by\n    temp_blks_written desc\n  limit 100\n) a;\n	\N	t	f	2020-05-05 17:15:29.285924-07	f	f	\N	\nwith q_data as (\n  select\n    (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n    (regexp_replace(md5(query), E'\\\\D', '', 'g'))::varchar(10)::int8 as tag_queryid,\n    '-' as tag_query,\n    array_to_string(array_agg(distinct quote_ident(pg_get_userbyid(userid))), ',') as users,\n    sum(s.calls)::int8 as calls,\n    round(sum(s.total_time)::numeric, 3)::double precision as total_time,\n    sum(shared_blks_hit)::int8 as shared_blks_hit,\n    sum(shared_blks_read)::int8 as shared_blks_read,\n    sum(shared_blks_written)::int8 as shared_blks_written,\n    sum(shared_blks_dirtied)::int8 as shared_blks_dirtied,\n    sum(temp_blks_read)::int8 as temp_blks_read,\n    sum(temp_blks_written)::int8 as temp_blks_written,\n    round(sum(blk_read_time)::numeric, 3)::double precision as blk_read_time,\n    round(sum(blk_write_time)::numeric, 3)::double precision as blk_write_time\n  from\n    pg_stat_statements s\n  where\n    calls > 5\n    and total_time > 0\n    and dbid = (select oid from pg_database where datname = current_database())\n    and not upper(s.query) like any (array['DEALLOCATE%', 'SET %', 'RESET %', 'BEGIN%', 'BEGIN;',\n      'COMMIT%', 'END%', 'ROLLBACK%', 'SHOW%'])\n  group by\n    tag_queryid\n)\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    total_time > 0\n  order by\n    total_time desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  order by\n    calls desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    shared_blks_read > 0\n  order by\n    shared_blks_read desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    shared_blks_written > 0\n  order by\n    shared_blks_written desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    temp_blks_read > 0\n  order by\n    temp_blks_read desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    temp_blks_written > 0\n  order by\n    temp_blks_written desc\n  limit 100\n) a;\n
98	stat_statements_no_query_text	9.4	\nwith q_data as (\n  select\n    (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n    queryid::text as tag_queryid,\n    '-' as tag_query,\n    array_to_string(array_agg(distinct quote_ident(pg_get_userbyid(userid))), ',') as users,\n    sum(s.calls)::int8 as calls,\n    round(sum(s.total_time)::numeric, 3)::double precision as total_time,\n    sum(shared_blks_hit)::int8 as shared_blks_hit,\n    sum(shared_blks_read)::int8 as shared_blks_read,\n    sum(shared_blks_written)::int8 as shared_blks_written,\n    sum(shared_blks_dirtied)::int8 as shared_blks_dirtied,\n    sum(temp_blks_read)::int8 as temp_blks_read,\n    sum(temp_blks_written)::int8 as temp_blks_written,\n    round(sum(blk_read_time)::numeric, 3)::double precision as blk_read_time,\n    round(sum(blk_write_time)::numeric, 3)::double precision as blk_write_time\n  from\n    get_stat_statements() s\n  where\n    calls > 5\n    and total_time > 0\n    and dbid = (select oid from pg_database where datname = current_database())\n    and not upper(s.query) like any (array['DEALLOCATE%', 'SET %', 'RESET %', 'BEGIN%', 'BEGIN;',\n      'COMMIT%', 'END%', 'ROLLBACK%', 'SHOW%'])\n  group by\n    queryid\n)\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    total_time > 0\n  order by\n    total_time desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  order by\n    calls desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    shared_blks_read > 0\n  order by\n    shared_blks_read desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    shared_blks_written > 0\n  order by\n    shared_blks_written desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    temp_blks_read > 0\n  order by\n    temp_blks_read desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    temp_blks_written > 0\n  order by\n    temp_blks_written desc\n  limit 100\n) a;\n	\N	t	f	2020-05-05 17:15:29.286791-07	f	f	\N	\nwith q_data as (\n  select\n    (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n    queryid::text as tag_queryid,\n    '-' as tag_query,\n    array_to_string(array_agg(distinct quote_ident(pg_get_userbyid(userid))), ',') as users,\n    sum(s.calls)::int8 as calls,\n    round(sum(s.total_time)::numeric, 3)::double precision as total_time,\n    sum(shared_blks_hit)::int8 as shared_blks_hit,\n    sum(shared_blks_read)::int8 as shared_blks_read,\n    sum(shared_blks_written)::int8 as shared_blks_written,\n    sum(shared_blks_dirtied)::int8 as shared_blks_dirtied,\n    sum(temp_blks_read)::int8 as temp_blks_read,\n    sum(temp_blks_written)::int8 as temp_blks_written,\n    round(sum(blk_read_time)::numeric, 3)::double precision as blk_read_time,\n    round(sum(blk_write_time)::numeric, 3)::double precision as blk_write_time\n  from\n    pg_stat_statements s\n  where\n    calls > 5\n    and total_time > 0\n    and dbid = (select oid from pg_database where datname = current_database())\n    and not upper(s.query) like any (array['DEALLOCATE%', 'SET %', 'RESET %', 'BEGIN%', 'BEGIN;',\n      'COMMIT%', 'END%', 'ROLLBACK%', 'SHOW%'])\n  group by\n    queryid\n)\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    total_time > 0\n  order by\n    total_time desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  order by\n    calls desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    shared_blks_read > 0\n  order by\n    shared_blks_read desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    shared_blks_written > 0\n  order by\n    shared_blks_written desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    temp_blks_read > 0\n  order by\n    temp_blks_read desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    temp_blks_written > 0\n  order by\n    temp_blks_written desc\n  limit 100\n) a;\n
99	stat_statements_calls	9.2	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  coalesce(sum(calls), 0)::int8 as calls,\n  coalesce(round(sum(total_time)::numeric, 3), 0)::float8 as total_time\nfrom\n  pg_stat_statements\nwhere\n  dbid = (select oid from pg_database where datname = current_database())\n;\n	\N	t	f	2020-05-05 17:15:29.287328-07	f	f	\N	
100	buffercache_by_db	9.2	\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  datname as tag_database,\n  count(*) * (current_setting('block_size')::int8) as size_b\nFROM\n  pg_buffercache AS b,\n  pg_database AS d\nWHERE\n  d.oid = b.reldatabase\nGROUP BY\n  datname;\n	\N	t	f	2020-05-05 17:15:29.28779-07	f	f	{"prometheus_gauge_columns": ["size_b"]}	
101	buffercache_by_type	9.2	\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  CASE\n    WHEN relkind = 'r' THEN 'Table'   -- TODO all relkinds covered?\n    WHEN relkind = 'i' THEN 'Index'\n    WHEN relkind = 't' THEN 'Toast'\n    WHEN relkind = 'm' THEN 'Materialized view'\n    ELSE 'Other'\n  END as tag_relkind,\n  count(*) * (current_setting('block_size')::int8) as size_b\nFROM\n  pg_buffercache AS b,\n  pg_class AS d\nWHERE\n  d.oid = b.relfilenode\nGROUP BY\n  relkind;\n	\N	t	f	2020-05-05 17:15:29.288213-07	f	f	{"prometheus_gauge_columns": ["size_b"]}	
102	stat_ssl	9.5	\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  ssl,\n  count(*)\nFROM\n  pg_stat_ssl AS s,\n  get_stat_activity() AS a\nWHERE\n  a.pid = s.pid\n  AND a.datname = current_database()\nGROUP BY\n  1, 2\n	\N	t	f	2020-05-05 17:15:29.288625-07	f	f	\N	\nSELECT\n(extract(epoch from now()) * 1e9)::int8 as epoch_ns,\nssl,\ncount(*)\n    FROM\n  pg_stat_ssl AS s,\npg_stat_activity AS a\nWHERE\n  a.pid = s.pid\n  AND a.datname = current_database()\nGROUP BY\n  1, 2;\n
103	database_conflicts	9.2	\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  confl_tablespace,\n  confl_lock,\n  confl_snapshot,\n  confl_bufferpin,\n  confl_deadlock\nFROM\n  pg_stat_database_conflicts\nWHERE\n  datname = current_database();\n	\N	t	f	2020-05-05 17:15:29.289019-07	f	t	\N	
104	locks	9.0	\nWITH q_locks AS (\n  select\n    *\n  from\n    pg_locks\n  where\n    pid != pg_backend_pid()\n    and database = (select oid from pg_database where datname = current_database())\n)\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  locktypes AS tag_locktype,\n  coalesce((select count(*) FROM q_locks WHERE locktype = locktypes), 0) AS count\nFROM\n  unnest('{relation, extend, page, tuple, transactionid, virtualxid, object, userlock, advisory}'::text[]) locktypes;\n	\N	t	f	2020-05-05 17:15:29.289505-07	f	f	{"prometheus_gauge_columns": ["count"]}	
105	locks_mode	9.0	\nWITH q_locks AS (\n  select\n    *\n  from\n    pg_locks\n  where\n    pid != pg_backend_pid()\n    and database = (select oid from pg_database where datname = current_database())\n)\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  lockmodes AS tag_lockmode,\n  coalesce((select count(*) FROM q_locks WHERE mode = lockmodes), 0) AS count\nFROM\n  unnest('{AccessShareLock, ExclusiveLock, RowShareLock, RowExclusiveLock, ShareLock, ShareRowExclusiveLock,  AccessExclusiveLock, ShareUpdateExclusiveLock}'::text[]) lockmodes;\n	\N	t	f	2020-05-05 17:15:29.289919-07	f	f	{"prometheus_gauge_columns": ["count"]}	
133	get_psutil_mem	9.1	\n/* Pre-requisites: PL/Pythonu and "psutil" Python package (e.g. pip install psutil) */\nCREATE EXTENSION IF NOT EXISTS plpython3u; -- NB! "plpython3u" might need changing to "plpythonu" (Python 2) everywhere for older OS-es\n\nCREATE OR REPLACE FUNCTION get_psutil_mem(\n\tOUT total float8, OUT used float8, OUT free float8, OUT buff_cache float8, OUT available float8, OUT percent float8,\n\tOUT swap_total float8, OUT swap_used float8, OUT swap_free float8, OUT swap_percent float8\n)\n LANGUAGE plpython3u\n SECURITY DEFINER\nAS $FUNCTION$\nfrom psutil import virtual_memory, swap_memory\nvm = virtual_memory()\nsw = swap_memory()\nreturn vm.total, vm.used, vm.free, vm.buffers + vm.cached, vm.available, vm.percent, sw.total, sw.used, sw.free, sw.percent\n$FUNCTION$;\n\nGRANT EXECUTE ON FUNCTION get_psutil_mem() TO pgwatch2;\nCOMMENT ON FUNCTION get_psutil_mem() IS 'created for pgwatch2';\n\n	\N	t	t	2020-05-05 17:15:29.307824-07	f	f	{"prometheus_all_gauge_columns": true}	
134	psutil_disk	9.1	\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  dir_or_tablespace as tag_dir_or_tablespace,\n  path as tag_path,\n  total, used, free, percent\nfrom\n  get_psutil_disk();\n	\N	t	f	2020-05-05 17:15:29.308414-07	f	f	{"prometheus_all_gauge_columns": true}	
106	blocking_locks	9.2	\nSELECT\n    (extract(epoch from now()) * 1e9)::int8 AS epoch_ns,\n    waiting.locktype           AS tag_waiting_locktype,\n    waiting_stm.usename        AS tag_waiting_user,\n    coalesce(waiting.mode, 'null'::text) AS tag_waiting_mode,\n    coalesce(waiting.relation::regclass::text, 'null') AS tag_waiting_table,\n    waiting_stm.query          AS waiting_query,\n    waiting.pid                AS waiting_pid,\n    other.locktype             AS other_locktype,\n    other.relation::regclass   AS other_table,\n    other_stm.query            AS other_query,\n    other.mode                 AS other_mode,\n    other.pid                  AS other_pid,\n    other_stm.usename          AS other_user\nFROM\n    pg_catalog.pg_locks AS waiting\nJOIN\n    get_stat_activity() AS waiting_stm\n    ON (\n        waiting_stm.pid = waiting.pid\n    )\nJOIN\n    pg_catalog.pg_locks AS other\n    ON (\n        (\n            waiting."database" = other."database"\n        AND waiting.relation  = other.relation\n        )\n        OR waiting.transactionid = other.transactionid\n    )\nJOIN\n    get_stat_activity() AS other_stm\n    ON (\n        other_stm.pid = other.pid\n    )\nWHERE\n    NOT waiting.GRANTED\nAND\n    waiting.pid <> other.pid\nAND\n    other.GRANTED\nAND\n    waiting_stm.datname = current_database();\n	\N	t	f	2020-05-05 17:15:29.29048-07	f	f	\N	\nWITH sa_snapshot AS (\n  select * from pg_stat_activity\n  where datname = current_database()\n  and not query like 'autovacuum:%'\n  and pid != pg_backend_pid()\n)\nSELECT\n    (extract(epoch from now()) * 1e9)::int8 AS epoch_ns,\n    waiting.locktype           AS tag_waiting_locktype,\n    waiting_stm.usename        AS tag_waiting_user,\n    coalesce(waiting.mode, 'null'::text) AS tag_waiting_mode,\n    coalesce(waiting.relation::regclass::text, 'null') AS tag_waiting_table,\n    waiting_stm.query          AS waiting_query,\n    waiting.pid                AS waiting_pid,\n    other.locktype             AS other_locktype,\n    other.relation::regclass   AS other_table,\n    other_stm.query            AS other_query,\n    other.mode                 AS other_mode,\n    other.pid                  AS other_pid,\n    other_stm.usename          AS other_user\nFROM\n    pg_catalog.pg_locks AS waiting\nJOIN\n    sa_snapshot AS waiting_stm\n    ON (\n        waiting_stm.pid = waiting.pid\n    )\nJOIN\n    pg_catalog.pg_locks AS other\n    ON (\n        (\n            waiting."database" = other."database"\n        AND waiting.relation  = other.relation\n        )\n        OR waiting.transactionid = other.transactionid\n    )\nJOIN\n    sa_snapshot AS other_stm\n    ON (\n        other_stm.pid = other.pid\n    )\nWHERE\n    NOT waiting.GRANTED\nAND\n    waiting.pid <> other.pid\nAND\n    other.GRANTED\nAND\n    waiting_stm.datname = current_database();\n
107	table_bloat_approx_stattuple	9.5	\n/* NB! accessing pgstattuple_approx directly requires superuser or pg_stat_scan_tables/pg_monitor builtin roles */\nselect\n  (extract(epoch from now()) * 1e9)::int8 AS epoch_ns,\n  quote_ident(n.nspname)||'.'||quote_ident(c.relname) as tag_full_table_name,\n  approx_free_percent,\n  approx_free_space as approx_free_space_b,\n  approx_tuple_count,\n  dead_tuple_percent,\n  dead_tuple_len as dead_tuple_len_b\nfrom\n  pg_class c\n  join lateral pgstattuple_approx(c.oid) st on (c.oid not in (select relation from pg_locks where mode = 'AccessExclusiveLock'))  -- skip locked tables,\n  join pg_namespace n on n.oid = c.relnamespace\nwhere\n  relkind in ('r', 'm')\n  and c.relpages >= 128 -- tables > 1mb\n  and not n.nspname like any (array[E'pg\\\\_%', 'information_schema']);\n	\N	t	f	2020-05-05 17:15:29.291042-07	t	f	{"prometheus_all_gauge_columns": true}	
108	get_table_bloat_approx	9.5	\nBEGIN;\n\nCREATE EXTENSION IF NOT EXISTS pgstattuple;\n\nCREATE OR REPLACE FUNCTION get_table_bloat_approx(\n  OUT approx_free_percent double precision, OUT approx_free_space double precision,\n  OUT dead_tuple_percent double precision, OUT dead_tuple_len double precision\n) AS\n$$\n    select\n      avg(approx_free_percent)::double precision as approx_free_percent,\n      sum(approx_free_space)::double precision as approx_free_space,\n      avg(dead_tuple_percent)::double precision as dead_tuple_percent,\n      sum(dead_tuple_len)::double precision as dead_tuple_len\n    from\n      pg_class c\n      join\n      pg_namespace n on n.oid = c.relnamespace\n      join lateral pgstattuple_approx(c.oid) on (c.oid not in (select relation from pg_locks where mode = 'AccessExclusiveLock'))  -- skip locked tables\n    where\n      relkind in ('r', 'm')\n      and c.relpages >= 128 -- tables >1mb\n      and not n.nspname like any (array[E'pg\\\\_%', 'information_schema'])\n$$ LANGUAGE sql SECURITY DEFINER;\n\nGRANT EXECUTE ON FUNCTION get_table_bloat_approx() TO pgwatch2;\nCOMMENT ON FUNCTION get_table_bloat_approx() is 'created for pgwatch2';\n\nCOMMIT;\n	for internal usage - when connecting user is marked as superuser then the daemon will automatically try to create the needed helpers on the monitored db	t	t	2020-05-05 17:15:29.291537-07	f	f	\N	
109	get_table_bloat_approx_sql	9.0	\n-- small modifications to SQL from https://github.com/ioguix/pgsql-bloat-estimation\n-- NB! monitoring user needs SELECT grant on all tables or a SECURITY DEFINER wrapper around that SQL\n\nCREATE OR REPLACE FUNCTION get_table_bloat_approx_sql(\n      OUT full_table_name text,\n      OUT approx_bloat_percent double precision,\n      OUT approx_bloat_bytes double precision,\n      OUT fillfactor integer\n    ) RETURNS SETOF RECORD\nLANGUAGE sql\nSECURITY DEFINER\nAS $$\n\nSELECT\n  quote_ident(schemaname)||'.'||quote_ident(tblname) as full_table_name,\n  bloat_ratio,\n  bloat_size,\n  fillfactor\nFROM (\n\n/* WARNING: executed with a non-superuser role, the query inspect only tables you are granted to read.\n* This query is compatible with PostgreSQL 9.0 and more\n*/\n         SELECT current_database(),\n                schemaname,\n                tblname,\n                bs * tblpages                  AS real_size,\n                (tblpages - est_tblpages) * bs AS extra_size,\n                CASE\n                    WHEN tblpages - est_tblpages > 0\n                        THEN 100 * (tblpages - est_tblpages) / tblpages::float\n                    ELSE 0\n                    END                        AS extra_ratio,\n                fillfactor,\n                CASE\n                    WHEN tblpages - est_tblpages_ff > 0\n                        THEN (tblpages - est_tblpages_ff) * bs\n                    ELSE 0\n                    END                        AS bloat_size,\n                CASE\n                    WHEN tblpages - est_tblpages_ff > 0\n                        THEN 100 * (tblpages - est_tblpages_ff) / tblpages::float\n                    ELSE 0\n                    END                        AS bloat_ratio,\n                is_na\n                -- , (pst).free_percent + (pst).dead_tuple_percent AS real_frag\n         FROM (\n                  SELECT ceil(reltuples / ((bs - page_hdr) / tpl_size)) + ceil(toasttuples / 4)                      AS est_tblpages,\n                         ceil(reltuples / ((bs - page_hdr) * fillfactor / (tpl_size * 100))) +\n                         ceil(toasttuples / 4)                                                                       AS est_tblpages_ff,\n                         tblpages,\n                         fillfactor,\n                         bs,\n                         tblid,\n                         schemaname,\n                         tblname,\n                         heappages,\n                         toastpages,\n                         is_na\n                         -- , stattuple.pgstattuple(tblid) AS pst\n                  FROM (\n                           SELECT (4 + tpl_hdr_size + tpl_data_size + (2 * ma)\n                               - CASE WHEN tpl_hdr_size % ma = 0 THEN ma ELSE tpl_hdr_size % ma END\n                               - CASE\n                                     WHEN ceil(tpl_data_size)::int % ma = 0 THEN ma\n                                     ELSE ceil(tpl_data_size)::int % ma END\n                                      )                    AS tpl_size,\n                                  bs - page_hdr            AS size_per_block,\n                                  (heappages + toastpages) AS tblpages,\n                                  heappages,\n                                  toastpages,\n                                  reltuples,\n                                  toasttuples,\n                                  bs,\n                                  page_hdr,\n                                  tblid,\n                                  schemaname,\n                                  tblname,\n                                  fillfactor,\n                                  is_na\n                           FROM (\n                                    SELECT tbl.oid                                                           AS tblid,\n                                           ns.nspname                                                        AS schemaname,\n                                           tbl.relname                                                       AS tblname,\n                                           tbl.reltuples,\n                                           tbl.relpages                                                      AS heappages,\n                                           coalesce(toast.relpages, 0)                                       AS toastpages,\n                                           coalesce(toast.reltuples, 0)                                      AS toasttuples,\n                                           coalesce(substring(\n                                                            array_to_string(tbl.reloptions, ' ')\n                                                            FROM 'fillfactor=([0-9]+)')::smallint,\n                                                    100)                                                     AS fillfactor,\n                                           current_setting('block_size')::numeric                            AS bs,\n                                           CASE\n                                               WHEN version() ~ 'mingw32' OR version() ~ '64-bit|x86_64|ppc64|ia64|amd64'\n                                                   THEN 8\n                                               ELSE 4 END                                                    AS ma,\n                                           24                                                                AS page_hdr,\n                                           23 + CASE\n                                                    WHEN MAX(coalesce(null_frac, 0)) > 0 THEN (7 + count(*)) / 8\n                                                    ELSE 0::int END\n                                               +\n                                           CASE WHEN tbl.relhasoids THEN 4 ELSE 0 END                        AS tpl_hdr_size,\n                                           sum((1 - coalesce(s.null_frac, 0)) * coalesce(s.avg_width, 1024)) AS tpl_data_size,\n                                           bool_or(att.atttypid = 'pg_catalog.name'::regtype)\n                                               OR count(att.attname) <> count(s.attname)                     AS is_na\n                                    FROM pg_attribute AS att\n                                             JOIN pg_class AS tbl ON att.attrelid = tbl.oid\n                                             JOIN pg_namespace AS ns ON ns.oid = tbl.relnamespace\n                                             LEFT JOIN pg_stats AS s ON s.schemaname = ns.nspname\n                                        AND s.tablename = tbl.relname AND s.inherited = false AND\n                                                                        s.attname = att.attname\n                                             LEFT JOIN pg_class AS toast ON tbl.reltoastrelid = toast.oid\n                                    WHERE att.attnum > 0\n                                      AND NOT att.attisdropped\n                                      AND tbl.relkind IN ('r', 'm')\n                                      AND ns.nspname != 'information_schema'\n                                    GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, tbl.relhasoids\n                                    ORDER BY 2, 3\n                                ) AS s\n                       ) AS s2\n              ) AS s3\n         WHERE NOT is_na\n ) s4\n$$;\n\nGRANT EXECUTE ON FUNCTION get_table_bloat_approx_sql() TO pgwatch2;\nCOMMENT ON FUNCTION get_table_bloat_approx_sql() is 'created for pgwatch2';\n\n	\N	t	t	2020-05-05 17:15:29.292313-07	f	f	\N	
110	get_table_bloat_approx_sql	12	\n-- small modifications to SQL from https://github.com/ioguix/pgsql-bloat-estimation\n-- NB! monitoring user needs SELECT grant on all tables or a SECURITY DEFINER wrapper around that SQL\n\nCREATE OR REPLACE FUNCTION get_table_bloat_approx_sql(\n      OUT full_table_name text,\n      OUT approx_bloat_percent double precision,\n      OUT approx_bloat_bytes double precision,\n      OUT fillfactor integer\n    ) RETURNS SETOF RECORD\nLANGUAGE sql\nSECURITY DEFINER\nAS $$\n\nSELECT\n  quote_ident(schemaname)||'.'||quote_ident(tblname) as full_table_name,\n  bloat_ratio,\n  bloat_size,\n  fillfactor\nFROM (\n\n/* WARNING: executed with a non-superuser role, the query inspect only tables you are granted to read.\n* This query is compatible with PostgreSQL 9.0 and more\n*/\n         SELECT current_database(),\n                schemaname,\n                tblname,\n                bs * tblpages                  AS real_size,\n                (tblpages - est_tblpages) * bs AS extra_size,\n                CASE\n                    WHEN tblpages - est_tblpages > 0\n                        THEN 100 * (tblpages - est_tblpages) / tblpages::float\n                    ELSE 0\n                    END                        AS extra_ratio,\n                fillfactor,\n                CASE\n                    WHEN tblpages - est_tblpages_ff > 0\n                        THEN (tblpages - est_tblpages_ff) * bs\n                    ELSE 0\n                    END                        AS bloat_size,\n                CASE\n                    WHEN tblpages - est_tblpages_ff > 0\n                        THEN 100 * (tblpages - est_tblpages_ff) / tblpages::float\n                    ELSE 0\n                    END                        AS bloat_ratio,\n                is_na\n                -- , (pst).free_percent + (pst).dead_tuple_percent AS real_frag\n         FROM (\n                  SELECT ceil(reltuples / ((bs - page_hdr) / tpl_size)) + ceil(toasttuples / 4)                      AS est_tblpages,\n                         ceil(reltuples / ((bs - page_hdr) * fillfactor / (tpl_size * 100))) +\n                         ceil(toasttuples / 4)                                                                       AS est_tblpages_ff,\n                         tblpages,\n                         fillfactor,\n                         bs,\n                         tblid,\n                         schemaname,\n                         tblname,\n                         heappages,\n                         toastpages,\n                         is_na\n                         -- , stattuple.pgstattuple(tblid) AS pst\n                  FROM (\n                           SELECT (4 + tpl_hdr_size + tpl_data_size + (2 * ma)\n                               - CASE WHEN tpl_hdr_size % ma = 0 THEN ma ELSE tpl_hdr_size % ma END\n                               - CASE\n                                     WHEN ceil(tpl_data_size)::int % ma = 0 THEN ma\n                                     ELSE ceil(tpl_data_size)::int % ma END\n                                      )                    AS tpl_size,\n                                  bs - page_hdr            AS size_per_block,\n                                  (heappages + toastpages) AS tblpages,\n                                  heappages,\n                                  toastpages,\n                                  reltuples,\n                                  toasttuples,\n                                  bs,\n                                  page_hdr,\n                                  tblid,\n                                  schemaname,\n                                  tblname,\n                                  fillfactor,\n                                  is_na\n                           FROM (\n                                    SELECT tbl.oid                                                           AS tblid,\n                                           ns.nspname                                                        AS schemaname,\n                                           tbl.relname                                                       AS tblname,\n                                           tbl.reltuples,\n                                           tbl.relpages                                                      AS heappages,\n                                           coalesce(toast.relpages, 0)                                       AS toastpages,\n                                           coalesce(toast.reltuples, 0)                                      AS toasttuples,\n                                           coalesce(substring(\n                                                            array_to_string(tbl.reloptions, ' ')\n                                                            FROM 'fillfactor=([0-9]+)')::smallint,\n                                                    100)                                                     AS fillfactor,\n                                           current_setting('block_size')::numeric                            AS bs,\n                                           CASE\n                                               WHEN version() ~ 'mingw32' OR version() ~ '64-bit|x86_64|ppc64|ia64|amd64'\n                                                   THEN 8\n                                               ELSE 4 END                                                    AS ma,\n                                           24                                                                AS page_hdr,\n                                           23 + CASE\n                                                    WHEN MAX(coalesce(null_frac, 0)) > 0 THEN (7 + count(*)) / 8\n                                                    ELSE 0::int END\n                                               +\n                                           0                                                                 AS tpl_hdr_size,\n                                           sum((1 - coalesce(s.null_frac, 0)) * coalesce(s.avg_width, 1024)) AS tpl_data_size,\n                                           bool_or(att.atttypid = 'pg_catalog.name'::regtype)\n                                               OR count(att.attname) <> count(s.attname)                     AS is_na\n                                    FROM pg_attribute AS att\n                                             JOIN pg_class AS tbl ON att.attrelid = tbl.oid\n                                             JOIN pg_namespace AS ns ON ns.oid = tbl.relnamespace\n                                             LEFT JOIN pg_stats AS s ON s.schemaname = ns.nspname\n                                        AND s.tablename = tbl.relname AND s.inherited = false AND\n                                                                        s.attname = att.attname\n                                             LEFT JOIN pg_class AS toast ON tbl.reltoastrelid = toast.oid\n                                    WHERE att.attnum > 0\n                                      AND NOT att.attisdropped\n                                      AND tbl.relkind IN ('r', 'm')\n                                      AND ns.nspname != 'information_schema'\n                                    GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n                                    ORDER BY 2, 3\n                                ) AS s\n                       ) AS s2\n              ) AS s3\n         WHERE NOT is_na\n ) s4\n$$;\n\nGRANT EXECUTE ON FUNCTION get_table_bloat_approx_sql() TO pgwatch2;\nCOMMENT ON FUNCTION get_table_bloat_approx_sql() is 'created for pgwatch2';\n\n	\N	t	t	2020-05-05 17:15:29.293673-07	f	f	\N	
111	table_bloat_approx_summary	9.5	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  approx_free_percent,\n  approx_free_space as approx_free_space_b,\n  dead_tuple_percent,\n  dead_tuple_len as dead_tuple_len_b\nfrom\n  get_table_bloat_approx()\nwhere\n  approx_free_space > 0\n	\N	t	f	2020-05-05 17:15:29.294722-07	t	f	{"prometheus_all_gauge_columns": true}	\nwith table_bloat_approx as (\n    select\n        avg(approx_free_percent)::double precision as approx_free_percent,\n        sum(approx_free_space)::double precision as approx_free_space,\n        avg(dead_tuple_percent)::double precision as dead_tuple_percent,\n        sum(dead_tuple_len)::double precision as dead_tuple_len\n    from\n        pg_class c\n            join\n        pg_namespace n on n.oid = c.relnamespace\n            join lateral pgstattuple_approx(c.oid) on (c.oid not in (select relation from pg_locks where mode = 'AccessExclusiveLock'))  -- skip locked tables\n    where\n        relkind in ('r', 'm')\n        and c.relpages >= 128 -- tables >1mb\n        and not n.nspname like any (array[E'pg\\\\_%', 'information_schema'])\n)\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  approx_free_percent,\n  approx_free_space as approx_free_space_b,\n  dead_tuple_percent,\n  dead_tuple_len as dead_tuple_len_b\nfrom\n  table_bloat_approx\nwhere\n  approx_free_space > 0;\n
112	table_bloat_approx_summary	10	\n/* NB! accessing pgstattuple_approx directly requires superuser or pg_stat_scan_tables/pg_monitor builtin roles or\n   execute grant on pgstattuple_approx(regclass)\n*/\nwith table_bloat_approx as (\n    select\n        avg(approx_free_percent)::double precision as approx_free_percent,\n        sum(approx_free_space)::double precision as approx_free_space,\n        avg(dead_tuple_percent)::double precision as dead_tuple_percent,\n        sum(dead_tuple_len)::double precision as dead_tuple_len\n    from\n        pg_class c\n            join\n        pg_namespace n on n.oid = c.relnamespace\n            join lateral pgstattuple_approx(c.oid) on (c.oid not in (select relation from pg_locks where mode = 'AccessExclusiveLock'))  -- skip locked tables\n    where\n        relkind in ('r', 'm')\n        and c.relpages >= 128 -- tables >1mb\n        and not n.nspname != 'information_schema'\n)\nselect\n    (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n    approx_free_percent,\n    approx_free_space as approx_free_space_b,\n    dead_tuple_percent,\n    dead_tuple_len as dead_tuple_len_b\nfrom\n    table_bloat_approx\nwhere\n     approx_free_space > 0;\n\n	\N	t	f	2020-05-05 17:15:29.295206-07	t	f	{"prometheus_all_gauge_columns": true}	
113	table_bloat_approx_summary_sql	9.0	\nWITH q_bloat AS (\n    select * from get_table_bloat_approx_sql()\n)\nSELECT\n    (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n    (select sum(approx_bloat_bytes) from q_bloat) as approx_table_bloat_b,\n    ((select sum(approx_bloat_bytes) from q_bloat) * 100 / pg_database_size(current_database()))::int8 as approx_bloat_percentage\n;\n	\N	t	f	2020-05-05 17:15:29.295961-07	t	f	{"prometheus_all_gauge_columns": true}	\nWITH q_bloat AS (\n    SELECT\n                quote_ident(schemaname)||'.'||quote_ident(tblname) as full_table_name,\n                bloat_ratio as approx_bloat_percent,\n                bloat_size as approx_bloat_bytes,\n                fillfactor\n    FROM (\n\n/* WARNING: executed with a non-superuser role, the query inspect only tables you are granted to read.\n* This query is compatible with PostgreSQL 9.0 and more\n*/\n             SELECT current_database(),\n                    schemaname,\n                    tblname,\n                    bs * tblpages                  AS real_size,\n                    (tblpages - est_tblpages) * bs AS extra_size,\n                    CASE\n                        WHEN tblpages - est_tblpages > 0\n                            THEN 100 * (tblpages - est_tblpages) / tblpages::float\n                        ELSE 0\n                        END                        AS extra_ratio,\n                    fillfactor,\n                    CASE\n                        WHEN tblpages - est_tblpages_ff > 0\n                            THEN (tblpages - est_tblpages_ff) * bs\n                        ELSE 0\n                        END                        AS bloat_size,\n                    CASE\n                        WHEN tblpages - est_tblpages_ff > 0\n                            THEN 100 * (tblpages - est_tblpages_ff) / tblpages::float\n                        ELSE 0\n                        END                        AS bloat_ratio,\n                    is_na\n                    -- , (pst).free_percent + (pst).dead_tuple_percent AS real_frag\n             FROM (\n                      SELECT ceil(reltuples / ((bs - page_hdr) / tpl_size)) + ceil(toasttuples / 4)                      AS est_tblpages,\n                             ceil(reltuples / ((bs - page_hdr) * fillfactor / (tpl_size * 100))) +\n                             ceil(toasttuples / 4)                                                                       AS est_tblpages_ff,\n                             tblpages,\n                             fillfactor,\n                             bs,\n                             tblid,\n                             schemaname,\n                             tblname,\n                             heappages,\n                             toastpages,\n                             is_na\n                             -- , stattuple.pgstattuple(tblid) AS pst\n                      FROM (\n                               SELECT (4 + tpl_hdr_size + tpl_data_size + (2 * ma)\n                                   - CASE WHEN tpl_hdr_size % ma = 0 THEN ma ELSE tpl_hdr_size % ma END\n                                   - CASE\n                                         WHEN ceil(tpl_data_size)::int % ma = 0 THEN ma\n                                         ELSE ceil(tpl_data_size)::int % ma END\n                                          )                    AS tpl_size,\n                                      bs - page_hdr            AS size_per_block,\n                                      (heappages + toastpages) AS tblpages,\n                                      heappages,\n                                      toastpages,\n                                      reltuples,\n                                      toasttuples,\n                                      bs,\n                                      page_hdr,\n                                      tblid,\n                                      schemaname,\n                                      tblname,\n                                      fillfactor,\n                                      is_na\n                               FROM (\n                                        SELECT tbl.oid                                                           AS tblid,\n                                               ns.nspname                                                        AS schemaname,\n                                               tbl.relname                                                       AS tblname,\n                                               tbl.reltuples,\n                                               tbl.relpages                                                      AS heappages,\n                                               coalesce(toast.relpages, 0)                                       AS toastpages,\n                                               coalesce(toast.reltuples, 0)                                      AS toasttuples,\n                                               coalesce(substring(\n                                                                array_to_string(tbl.reloptions, ' ')\n                                                                FROM 'fillfactor=([0-9]+)')::smallint,\n                                                        100)                                                     AS fillfactor,\n                                               current_setting('block_size')::numeric                            AS bs,\n                                               CASE\n                                                   WHEN version() ~ 'mingw32' OR version() ~ '64-bit|x86_64|ppc64|ia64|amd64'\n                                                       THEN 8\n                                                   ELSE 4 END                                                    AS ma,\n                                               24                                                                AS page_hdr,\n                                               23 + CASE\n                                                        WHEN MAX(coalesce(null_frac, 0)) > 0 THEN (7 + count(*)) / 8\n                                                        ELSE 0::int END\n                                                   +\n                                               CASE WHEN tbl.relhasoids THEN 4 ELSE 0 END                        AS tpl_hdr_size,\n                                               sum((1 - coalesce(s.null_frac, 0)) * coalesce(s.avg_width, 1024)) AS tpl_data_size,\n                                               bool_or(att.atttypid = 'pg_catalog.name'::regtype)\n                                                   OR count(att.attname) <> count(s.attname)                     AS is_na\n                                        FROM pg_attribute AS att\n                                                 JOIN pg_class AS tbl ON att.attrelid = tbl.oid\n                                                 JOIN pg_namespace AS ns ON ns.oid = tbl.relnamespace\n                                                 LEFT JOIN pg_stats AS s ON s.schemaname = ns.nspname\n                                            AND s.tablename = tbl.relname AND s.inherited = false AND\n                                                                            s.attname = att.attname\n                                                 LEFT JOIN pg_class AS toast ON tbl.reltoastrelid = toast.oid\n                                        WHERE att.attnum > 0\n                                          AND NOT att.attisdropped\n                                          AND tbl.relkind IN ('r', 'm')\n                                          AND ns.nspname != 'information_schema'\n                                        GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, tbl.relhasoids\n                                        ORDER BY 2, 3\n                                    ) AS s\n                           ) AS s2\n                  ) AS s3\n             -- WHERE NOT is_na\n         ) s4\n)\nSELECT\n    (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n    (select sum(approx_bloat_bytes) from q_bloat) as approx_table_bloat_b,\n    ((select sum(approx_bloat_bytes) from q_bloat) * 100 / pg_database_size(current_database()))::int8 as approx_bloat_percentage;\n
117	table_hashes	9.0	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  quote_ident(table_schema)||'.'||quote_ident(table_name) as tag_table,\n  md5((array_agg((c.*)::text order by ordinal_position))::text)\nfrom (\n         SELECT current_database()::information_schema.sql_identifier AS table_catalog, nc.nspname::information_schema.sql_identifier AS table_schema, c.relname::information_schema.sql_identifier AS table_name, a.attname::information_schema.sql_identifier AS column_name, a.attnum::information_schema.cardinal_number AS ordinal_position, pg_get_expr(ad.adbin, ad.adrelid)::information_schema.character_data AS column_default,\n                CASE\n                    WHEN a.attnotnull OR t.typtype = 'd'::"char" AND t.typnotnull THEN 'NO'::text\n                    ELSE 'YES'::text\n                    END::information_schema.yes_or_no AS is_nullable,\n                CASE\n                    WHEN t.typtype = 'd'::"char" THEN\n                        CASE\n                            WHEN bt.typelem <> 0::oid AND bt.typlen = (-1) THEN 'ARRAY'::text\n                            WHEN nbt.nspname = 'pg_catalog'::name THEN format_type(t.typbasetype, NULL::integer)\n                            ELSE 'USER-DEFINED'::text\n                            END\n                    ELSE\n                        CASE\n                            WHEN t.typelem <> 0::oid AND t.typlen = (-1) THEN 'ARRAY'::text\n                            WHEN nt.nspname = 'pg_catalog'::name THEN format_type(a.atttypid, NULL::integer)\n                            ELSE 'USER-DEFINED'::text\n                            END\n                    END::information_schema.character_data AS data_type, information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number AS character_maximum_length, information_schema._pg_char_octet_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number AS character_octet_length, information_schema._pg_numeric_precision(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number AS numeric_precision, information_schema._pg_numeric_precision_radix(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number AS numeric_precision_radix, information_schema._pg_numeric_scale(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number AS numeric_scale, information_schema._pg_datetime_precision(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number AS datetime_precision, NULL::character varying::information_schema.character_data AS interval_type, NULL::character varying::information_schema.character_data AS interval_precision, NULL::character varying::information_schema.sql_identifier AS character_set_catalog, NULL::character varying::information_schema.sql_identifier AS character_set_schema, NULL::character varying::information_schema.sql_identifier AS character_set_name, NULL::character varying::information_schema.sql_identifier AS collation_catalog, NULL::character varying::information_schema.sql_identifier AS collation_schema, NULL::character varying::information_schema.sql_identifier AS collation_name,\n                CASE\n                    WHEN t.typtype = 'd'::"char" THEN current_database()\n                    ELSE NULL::name\n                    END::information_schema.sql_identifier AS domain_catalog,\n                CASE\n                    WHEN t.typtype = 'd'::"char" THEN nt.nspname\n                    ELSE NULL::name\n                    END::information_schema.sql_identifier AS domain_schema,\n                CASE\n                    WHEN t.typtype = 'd'::"char" THEN t.typname\n                    ELSE NULL::name\n                    END::information_schema.sql_identifier AS domain_name, current_database()::information_schema.sql_identifier AS udt_catalog, COALESCE(nbt.nspname, nt.nspname)::information_schema.sql_identifier AS udt_schema, COALESCE(bt.typname, t.typname)::information_schema.sql_identifier AS udt_name, NULL::character varying::information_schema.sql_identifier AS scope_catalog, NULL::character varying::information_schema.sql_identifier AS scope_schema, NULL::character varying::information_schema.sql_identifier AS scope_name, NULL::integer::information_schema.cardinal_number AS maximum_cardinality, a.attnum::information_schema.sql_identifier AS dtd_identifier, 'NO'::character varying::information_schema.yes_or_no AS is_self_referencing, 'NO'::character varying::information_schema.yes_or_no AS is_identity, NULL::character varying::information_schema.character_data AS identity_generation, NULL::character varying::information_schema.character_data AS identity_start, NULL::character varying::information_schema.character_data AS identity_increment, NULL::character varying::information_schema.character_data AS identity_maximum, NULL::character varying::information_schema.character_data AS identity_minimum, NULL::character varying::information_schema.yes_or_no AS identity_cycle, 'NEVER'::character varying::information_schema.character_data AS is_generated, NULL::character varying::information_schema.character_data AS generation_expression,\n                CASE\n                    WHEN c.relkind = 'r'::"char" OR c.relkind = 'v'::"char" AND (EXISTS ( SELECT 1\n                                                                                          FROM pg_rewrite\n                                                                                          WHERE pg_rewrite.ev_class = c.oid AND pg_rewrite.ev_type = '2'::"char" AND pg_rewrite.is_instead)) AND (EXISTS ( SELECT 1\n                                                                                                                                                                                                           FROM pg_rewrite\n                                                                                                                                                                                                           WHERE pg_rewrite.ev_class = c.oid AND pg_rewrite.ev_type = '4'::"char" AND pg_rewrite.is_instead)) THEN 'YES'::text\n                    ELSE 'NO'::text\n                    END::information_schema.yes_or_no AS is_updatable\n         FROM pg_attribute a\n                  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid AND a.attnum = ad.adnum, pg_class c, pg_namespace nc, pg_type t\n                                                                                                                               JOIN pg_namespace nt ON t.typnamespace = nt.oid\n                                                                                                                               LEFT JOIN (pg_type bt\n             JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid) ON t.typtype = 'd'::"char" AND t.typbasetype = bt.oid\n         WHERE a.attrelid = c.oid AND a.atttypid = t.oid AND nc.oid = c.relnamespace AND NOT pg_is_other_temp_schema(nc.oid) AND a.attnum > 0 AND NOT a.attisdropped AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char"])) AND (pg_has_role(c.relowner, 'USAGE'::text) OR has_column_privilege(c.oid, a.attnum, 'SELECT, INSERT, UPDATE, REFERENCES'::text))\n) c\nwhere\n  not table_schema like any (array[E'pg\\\\_%', 'information_schema'])\ngroup by\n  table_schema, table_name\norder by\n  table_schema, table_name;\n	\N	t	f	2020-05-05 17:15:29.299608-07	f	f	\N	
118	table_hashes	9.3	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  quote_ident(table_schema)||'.'||quote_ident(table_name) as tag_table,\n  md5((array_agg((c.*)::text order by ordinal_position))::text)\nfrom (\n SELECT current_database()::information_schema.sql_identifier AS table_catalog,\n    nc.nspname::information_schema.sql_identifier AS table_schema,\n    c.relname::information_schema.sql_identifier AS table_name,\n    a.attname::information_schema.sql_identifier AS column_name,\n    a.attnum::information_schema.cardinal_number AS ordinal_position,\n    pg_get_expr(ad.adbin, ad.adrelid)::information_schema.character_data AS column_default,\n        CASE\n            WHEN a.attnotnull OR t.typtype = 'd'::"char" AND t.typnotnull THEN 'NO'::text\n            ELSE 'YES'::text\n        END::information_schema.yes_or_no AS is_nullable,\n        CASE\n            WHEN t.typtype = 'd'::"char" THEN\n            CASE\n                WHEN bt.typelem <> 0::oid AND bt.typlen = '-1'::integer THEN 'ARRAY'::text\n                WHEN nbt.nspname = 'pg_catalog'::name THEN format_type(t.typbasetype, NULL::integer)\n                ELSE 'USER-DEFINED'::text\n            END\n            ELSE\n            CASE\n                WHEN t.typelem <> 0::oid AND t.typlen = '-1'::integer THEN 'ARRAY'::text\n                WHEN nt.nspname = 'pg_catalog'::name THEN format_type(a.atttypid, NULL::integer)\n                ELSE 'USER-DEFINED'::text\n            END\n        END::information_schema.character_data AS data_type,\n    information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number AS character_maximum_length,\n    information_schema._pg_char_octet_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number AS character_octet_length,\n    information_schema._pg_numeric_precision(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number AS numeric_precision,\n    information_schema._pg_numeric_precision_radix(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number AS numeric_precision_radix,\n    information_schema._pg_numeric_scale(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number AS numeric_scale,\n    information_schema._pg_datetime_precision(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number AS datetime_precision,\n    information_schema._pg_interval_type(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.character_data AS interval_type,\n    NULL::integer::information_schema.cardinal_number AS interval_precision,\n    NULL::character varying::information_schema.sql_identifier AS character_set_catalog,\n    NULL::character varying::information_schema.sql_identifier AS character_set_schema,\n    NULL::character varying::information_schema.sql_identifier AS character_set_name,\n        CASE\n            WHEN nco.nspname IS NOT NULL THEN current_database()\n            ELSE NULL::name\n        END::information_schema.sql_identifier AS collation_catalog,\n    nco.nspname::information_schema.sql_identifier AS collation_schema,\n    co.collname::information_schema.sql_identifier AS collation_name,\n        CASE\n            WHEN t.typtype = 'd'::"char" THEN current_database()\n            ELSE NULL::name\n        END::information_schema.sql_identifier AS domain_catalog,\n        CASE\n            WHEN t.typtype = 'd'::"char" THEN nt.nspname\n            ELSE NULL::name\n        END::information_schema.sql_identifier AS domain_schema,\n        CASE\n            WHEN t.typtype = 'd'::"char" THEN t.typname\n            ELSE NULL::name\n        END::information_schema.sql_identifier AS domain_name,\n    current_database()::information_schema.sql_identifier AS udt_catalog,\n    COALESCE(nbt.nspname, nt.nspname)::information_schema.sql_identifier AS udt_schema,\n    COALESCE(bt.typname, t.typname)::information_schema.sql_identifier AS udt_name,\n    NULL::character varying::information_schema.sql_identifier AS scope_catalog,\n    NULL::character varying::information_schema.sql_identifier AS scope_schema,\n    NULL::character varying::information_schema.sql_identifier AS scope_name,\n    NULL::integer::information_schema.cardinal_number AS maximum_cardinality,\n    a.attnum::information_schema.sql_identifier AS dtd_identifier,\n    'NO'::character varying::information_schema.yes_or_no AS is_self_referencing,\n    'NO'::character varying::information_schema.yes_or_no AS is_identity,\n    NULL::character varying::information_schema.character_data AS identity_generation,\n    NULL::character varying::information_schema.character_data AS identity_start,\n    NULL::character varying::information_schema.character_data AS identity_increment,\n    NULL::character varying::information_schema.character_data AS identity_maximum,\n    NULL::character varying::information_schema.character_data AS identity_minimum,\n    NULL::character varying::information_schema.yes_or_no AS identity_cycle,\n    'NEVER'::character varying::information_schema.character_data AS is_generated,\n    NULL::character varying::information_schema.character_data AS generation_expression,\n        CASE\n            WHEN c.relkind = 'r'::"char" OR (c.relkind = ANY (ARRAY['v'::"char", 'f'::"char"])) AND pg_column_is_updatable(c.oid::regclass, a.attnum, false) THEN 'YES'::text\n            ELSE 'NO'::text\n        END::information_schema.yes_or_no AS is_updatable\n   FROM pg_attribute a\n     LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid AND a.attnum = ad.adnum\n     JOIN (pg_class c\n     JOIN pg_namespace nc ON c.relnamespace = nc.oid) ON a.attrelid = c.oid\n     JOIN (pg_type t\n     JOIN pg_namespace nt ON t.typnamespace = nt.oid) ON a.atttypid = t.oid\n     LEFT JOIN (pg_type bt\n     JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid) ON t.typtype = 'd'::"char" AND t.typbasetype = bt.oid\n     LEFT JOIN (pg_collation co\n     JOIN pg_namespace nco ON co.collnamespace = nco.oid) ON a.attcollation = co.oid AND (nco.nspname <> 'pg_catalog'::name OR co.collname <> 'default'::name)\n  WHERE NOT pg_is_other_temp_schema(nc.oid) AND a.attnum > 0 AND NOT a.attisdropped AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char"]))\n\n) c\nwhere\n  not table_schema like any (array[E'pg\\\\_%', 'information_schema'])\ngroup by\n  table_schema, table_name\norder by\n  table_schema, table_name;\n	\N	t	f	2020-05-05 17:15:29.3006-07	f	f	\N	
119	configuration_hashes	9.0	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  name as tag_setting,\n  coalesce(reset_val, '') as value\nfrom\n  pg_settings;\n	\N	t	f	2020-05-05 17:15:29.301305-07	f	f	\N	
120	index_hashes	9.0	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  quote_ident(nspname)||'.'||quote_ident(c.relname) as tag_index,\n  quote_ident(nspname)||'.'||quote_ident(r.relname) as "table",\n  i.indisvalid::text as is_valid,\n  coalesce(md5(pg_get_indexdef(i.indexrelid)), random()::text) as md5\nfrom\n  pg_index i\n  join\n  pg_class c on c.oid = i.indexrelid\n  join\n  pg_class r on r.oid = i.indrelid\n  join\n  pg_namespace n on n.oid = c.relnamespace\nwhere\n  c.relnamespace not in (select oid from pg_namespace where nspname like any(array[E'pg\\\\_%', 'information_schema']));\n	\N	t	f	2020-05-05 17:15:29.301764-07	f	f	\N	
121	get_load_average	9.1	\nBEGIN;\n\nCREATE EXTENSION IF NOT EXISTS plpython3u;\n\nCREATE OR REPLACE FUNCTION get_load_average(OUT load_1min float, OUT load_5min float, OUT load_15min float) AS\n$$\nfrom os import getloadavg\nla = getloadavg()\nreturn [la[0], la[1], la[2]]\n$$ LANGUAGE plpython3u VOLATILE SECURITY DEFINER;\n\nGRANT EXECUTE ON FUNCTION get_load_average() TO pgwatch2;\n\nCOMMENT ON FUNCTION get_load_average() is 'created for pgwatch2';\n\nCOMMIT;\n	for internal usage - when connecting user is marked as superuser then the daemon will automatically try to create the needed helpers on the monitored db	t	t	2020-05-05 17:15:29.302185-07	f	f	\N	
122	get_load_average_copy	9.0	\nBEGIN;\n\nCREATE UNLOGGED TABLE IF NOT EXISTS get_load_average_copy /* remove the UNLOGGED and IF NOT EXISTS part for < v9.1 */\n(\n    load_1min  float,\n    load_5min  float,\n    load_15min float,\n    proc_count text,\n    last_procid int,\n    created_on timestamptz not null default now()\n);\n\nCREATE OR REPLACE FUNCTION get_load_average_copy(OUT load_1min float, OUT load_5min float, OUT load_15min float) AS\n$$\nbegin\n    if random() < 0.02 then    /* clear the table on ca every 50th call not to be bigger than a couple of pages */\n        truncate get_load_average_copy;\n    end if;\n    copy get_load_average_copy (load_1min, load_5min, load_15min, proc_count, last_procid) from '/proc/loadavg' with (format csv, delimiter ' ');\n    select t.load_1min, t.load_5min, t.load_15min into load_1min, load_5min, load_15min from get_load_average_copy t order by created_on desc nulls last limit 1;\n    return;\nend;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\nGRANT EXECUTE ON FUNCTION get_load_average_copy() TO pgwatch2;\n\nCOMMENT ON FUNCTION get_load_average_copy() is 'created for pgwatch2';\n\nCOMMIT;\n	for internal usage - when connecting user is marked as superuser then the daemon will automatically try to create the needed helpers on the monitored db	t	t	2020-05-05 17:15:29.302614-07	f	f	\N	
123	get_load_average_windows	9.0	\n/*\n\n Python function for Windows that is used to extract CPU load from machine via SQL. Since\n os.getloadavg() function is unavailable for Windows, ctypes and kernel32.GetSystemTimes()\n used\n\n*/\n--DROP TYPE load_average;\n--DROP FUNCTION get_load_average();\n--DROP FUNCTION cpu();\n\nBEGIN;\n\nDROP TYPE IF EXISTS load_average CASCADE;\n\nCREATE TYPE load_average AS ( load_1min real, load_5min real, load_15min real );\n\nCREATE OR REPLACE FUNCTION cpu() RETURNS real AS\n$$\n\tfrom ctypes import windll, Structure, sizeof, byref\n\tfrom ctypes.wintypes import DWORD\n\timport time\n\n\tclass FILETIME(Structure):\n\t   _fields_ = [("dwLowDateTime", DWORD), ("dwHighDateTime", DWORD)]\n\n\tdef GetSystemTimes():\n\t    __GetSystemTimes = windll.kernel32.GetSystemTimes\n\t    idleTime, kernelTime, userTime = FILETIME(), FILETIME(), FILETIME()\n\t    success = __GetSystemTimes(byref(idleTime), byref(kernelTime), byref(userTime))\n\t    assert success, ctypes.WinError(ctypes.GetLastError())[1]\n\t    return {\n\t        "idleTime": idleTime.dwLowDateTime,\n\t        "kernelTime": kernelTime.dwLowDateTime,\n\t        "userTime": userTime.dwLowDateTime\n\t       }\n\n\tFirstSystemTimes = GetSystemTimes()\n\ttime.sleep(0.2)\n\tSecSystemTimes = GetSystemTimes()\n\n\tusr = SecSystemTimes['userTime'] - FirstSystemTimes['userTime']\n\tker = SecSystemTimes['kernelTime'] - FirstSystemTimes['kernelTime']\n\tidl = SecSystemTimes['idleTime'] - FirstSystemTimes['idleTime']\n\n\tsys = ker + usr\n\treturn min((sys - idl) *100 / sys, 100)\n$$ LANGUAGE plpython3u;\n\nCREATE OR REPLACE FUNCTION get_load_average_windows() RETURNS load_average AS\n$$\n\tSELECT val, val, val FROM cpu() AS cpu_now(val);\n$$ LANGUAGE sql;\n\nGRANT EXECUTE ON FUNCTION get_load_average_windows() TO pgwatch2;\n\nCOMMENT ON FUNCTION get_load_average_windows() is 'created for pgwatch2';\n\nCOMMIT;\n\n	for internal usage - when connecting user is marked as superuser then the daemon will automatically try to create the needed helpers on the monitored db	t	t	2020-05-05 17:15:29.303095-07	f	f	\N	
124	get_stat_statements	9.2	\nCREATE EXTENSION IF NOT EXISTS pg_stat_statements;\n\nCREATE OR REPLACE FUNCTION get_stat_statements() RETURNS TABLE (\n\tqueryid int8, query text, calls int8, total_time float8, rows int8, shared_blks_hit int8, shared_blks_read int8,\n\tshared_blks_dirtied int8, shared_blks_written int8, local_blks_hit int8, local_blks_read int8, local_blks_dirtied int8,\n\tlocal_blks_written int8, temp_blks_read int8, temp_blks_written int8, blk_read_time float8, blk_write_time float8,\n  userid int8, dbid int8\n) AS\n$$\n  select\n    /* for versions <9.4 we need to spoof the queryid column to make data usable /linkable in Grafana */\n    (regexp_replace(md5(s.query), E'\\\\D', '', 'g'))::varchar(10)::int8 as queryid,\n  \ts.query, s.calls, s.total_time, s.rows, s.shared_blks_hit, s.shared_blks_read, s.shared_blks_dirtied, s.shared_blks_written,\n  \ts.local_blks_hit, s.local_blks_read, s.local_blks_dirtied, s.local_blks_written, s.temp_blks_read, s.temp_blks_written,\n  \ts.blk_read_time, s.blk_write_time, s.userid::int8, s.dbid::int8\n  from\n    pg_stat_statements s\n    join\n    pg_database d\n      on d.oid = s.dbid and d.datname = current_database()\n$$ LANGUAGE sql VOLATILE SECURITY DEFINER;\n\nGRANT EXECUTE ON FUNCTION get_stat_statements() TO pgwatch2;\nCOMMENT ON FUNCTION get_stat_statements() IS 'created for pgwatch2';\n\n	for internal usage - when connecting user is marked as superuser then the daemon will automatically try to create the needed helpers on the monitored db	t	t	2020-05-05 17:15:29.303583-07	f	f	\N	
125	get_stat_statements	9.4	\nCREATE EXTENSION IF NOT EXISTS pg_stat_statements;\n\nCREATE OR REPLACE FUNCTION get_stat_statements() RETURNS SETOF pg_stat_statements AS\n$$\n  select\n    s.*\n  from\n    pg_stat_statements s\n    join\n    pg_database d\n      on d.oid = s.dbid and d.datname = current_database()\n$$ LANGUAGE sql VOLATILE SECURITY DEFINER;\n\nGRANT EXECUTE ON FUNCTION get_stat_statements() TO pgwatch2;\nCOMMENT ON FUNCTION get_stat_statements() IS 'created for pgwatch2';\n\n	for internal usage - when connecting user is marked as superuser then the daemon will automatically try to create the needed helpers on the monitored db	t	t	2020-05-05 17:15:29.304045-07	f	f	\N	
126	pgbouncer_stats	0	show stats	pgbouncer per db statistics	t	f	2020-05-05 17:15:29.304403-07	f	f	\N	
127	get_stat_activity	9.0	\n\nDO $OUTER$\nDECLARE\n  l_pgver double precision;\n  l_sproc_text_pre92 text := $SQL$\nCREATE OR REPLACE FUNCTION get_stat_activity() RETURNS SETOF pg_stat_activity AS\n$$\n  select * from pg_stat_activity where datname = current_database() and procpid != pg_backend_pid()\n$$ LANGUAGE sql VOLATILE SECURITY DEFINER;\n$SQL$;\n  l_sproc_text_92_plus text := $SQL$\nCREATE OR REPLACE FUNCTION get_stat_activity() RETURNS SETOF pg_stat_activity AS\n$$\n  select * from pg_stat_activity where datname = current_database() and pid != pg_backend_pid()\n$$ LANGUAGE sql VOLATILE SECURITY DEFINER;\n$SQL$;\nBEGIN\n  SELECT ((regexp_matches(\n      regexp_replace(current_setting('server_version'), '(beta|devel).*', '', 'g'),\n        E'\\\\d+\\\\.?\\\\d+?'))[1])::double precision INTO l_pgver;\n  EXECUTE format(CASE WHEN l_pgver > 9.1 THEN l_sproc_text_92_plus ELSE l_sproc_text_pre92 END);\nEND;\n$OUTER$;\n\nGRANT EXECUTE ON FUNCTION get_stat_activity() TO pgwatch2;\nCOMMENT ON FUNCTION get_stat_activity() IS 'created for pgwatch2';\n\n	for internal usage - when connecting user is marked as superuser then the daemon will automatically try to create the needed helpers on the monitored db	t	t	2020-05-05 17:15:29.304862-07	f	f	\N	
128	replication_slots	9.4	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  slot_name::text as tag_slot_name,\n  coalesce(plugin, 'physical')::text as tag_plugin,\n  active,\n  case when active then 0 else 1 end as non_active_int,\n  pg_xlog_location_diff(pg_current_xlog_location(), restart_lsn)::int8 as restart_lsn_lag_b,\n  greatest(age(xmin), age(catalog_xmin))::int8 as xmin_age_tx\nfrom\n  pg_replication_slots;\n	\N	t	f	2020-05-05 17:15:29.305252-07	t	f	{"prometheus_all_gauge_columns": true}	
129	replication_slots	10	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  slot_name::text as tag_slot_name,\n  coalesce(plugin, 'physical')::text as plugin,\n  active,\n  case when active then 0 else 1 end as non_active_int,\n  pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn)::int8 as restart_lsn_lag_b,\n  greatest(age(xmin), age(catalog_xmin))::int8 as xmin_age_tx\nfrom\n  pg_replication_slots;\n	\N	t	f	2020-05-05 17:15:29.305617-07	t	f	{"prometheus_all_gauge_columns": true}	
130	psutil_cpu	9.1	\n\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  round(cpu_utilization::numeric, 2)::float as cpu_utilization,\n  round(load_1m_norm::numeric, 2)::float as load_1m_norm,\n  round(load_1m::numeric, 2)::float as load_1m,\n  round(load_5m_norm::numeric, 2)::float as load_5m_norm,\n  round(load_5m::numeric, 2)::float as load_5m,\n  round("user"::numeric, 2)::float as "user",\n  round(system::numeric, 2)::float as system,\n  round(idle::numeric, 2)::float as idle,\n  round(iowait::numeric, 2)::float as iowait,\n  round(irqs::numeric, 2)::float as irqs,\n  round(other::numeric, 2)::float as other\nfrom\n  get_psutil_cpu();\n	\N	t	f	2020-05-05 17:15:29.306013-07	f	f	{"prometheus_all_gauge_columns": true}	
131	get_psutil_cpu	9.1	\n/*  Pre-requisites: PL/Pythonu and "psutil" Python package (e.g. pip install psutil)\n    NB! "psutil" is known to behave differently depending on the used version and operating system, so if getting\n    errors please adjust to your needs. "psutil" documentation here: https://psutil.readthedocs.io/en/latest/\n*/\nCREATE EXTENSION IF NOT EXISTS plpython3u; /* NB! "plpython3u" might need changing to "plpythonu" (Python 2) everywhere for older OS-es */\n\nCREATE OR REPLACE FUNCTION get_psutil_cpu(\n\tOUT cpu_utilization float8, OUT load_1m_norm float8, OUT load_1m float8, OUT load_5m_norm float8, OUT load_5m float8,\n    OUT "user" float8, OUT system float8, OUT idle float8, OUT iowait float8, OUT irqs float8, OUT other float8\n)\n LANGUAGE plpython3u\n SECURITY DEFINER\nAS $FUNCTION$\n\nfrom os import getloadavg\nfrom psutil import cpu_times_percent, cpu_percent, cpu_count\nfrom threading import Thread\n\nclass GetCpuPercentThread(Thread):\n    def __init__(self, interval_seconds):\n        self.interval_seconds = interval_seconds\n        self.cpu_utilization_info = None\n        super(GetCpuPercentThread, self).__init__()\n\n    def run(self):\n        self.cpu_utilization_info = cpu_percent(self.interval_seconds)\n\nt = GetCpuPercentThread(0.5)\nt.start()\n\nct = cpu_times_percent(0.5)\nla = getloadavg()\n\nt.join()\n\nreturn t.cpu_utilization_info, la[0] / cpu_count(), la[0], la[1] / cpu_count(), la[1], ct.user, ct.system, ct.idle, ct.iowait, ct.irq + ct.softirq, ct.steal + ct.guest + ct.guest_nice\n\n$FUNCTION$;\n\nGRANT EXECUTE ON FUNCTION get_psutil_cpu() TO pgwatch2;\nCOMMENT ON FUNCTION get_psutil_cpu() IS 'created for pgwatch2';\n\n\n	\N	t	t	2020-05-05 17:15:29.306546-07	f	f	{"prometheus_all_gauge_columns": true}	
132	psutil_mem	9.1	\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  total, used, free, buff_cache, available, percent,\n  swap_total, swap_used, swap_free, swap_percent\nfrom\n  get_psutil_mem();\n	\N	t	f	2020-05-05 17:15:29.307212-07	f	f	{"prometheus_all_gauge_columns": true}	
135	get_psutil_disk	9.1	\n/* Pre-requisites: PL/Pythonu and "psutil" Python package (e.g. pip install psutil) */\nCREATE EXTENSION IF NOT EXISTS plpython3u; /* NB! "plpython3u" might need changing to "plpythonu" (Python 2) everywhere for older OS-es */\n\nCREATE OR REPLACE FUNCTION get_psutil_disk(\n\tOUT dir_or_tablespace text, OUT path text, OUT total float8, OUT used float8, OUT free float8, OUT percent float8\n)\n RETURNS SETOF record\n LANGUAGE plpython3u\n SECURITY DEFINER\nAS $FUNCTION$\n\nfrom os import stat\nfrom os.path import join, exists\nfrom psutil import disk_usage\nret_list = []\n\n# data_directory\nr = plpy.execute("select current_setting('data_directory') as dd, current_setting('log_directory') as ld, current_setting('server_version_num')::int as pgver")\ndd = r[0]['dd']\nld = r[0]['ld']\ndu_dd = disk_usage(dd)\nret_list.append(['data_directory', dd, du_dd.total, du_dd.used, du_dd.free, du_dd.percent])\n\ndd_stat = stat(dd)\n# log_directory\nif ld:\n    if not ld.startswith('/'):\n        ld_path = join(dd, ld)\n    else:\n        ld_path = ld\n    if exists(ld_path):\n        log_stat = stat(ld_path)\n        if log_stat.st_dev == dd_stat.st_dev:\n            pass                                # no new info, same device\n        else:\n            du = disk_usage(ld_path)\n            ret_list.append(['log_directory', ld_path, du.total, du.used, du.free, du.percent])\n\n# WAL / XLOG directory\n# plpy.notice('pg_wal' if r[0]['pgver'] >= 100000 else 'pg_xlog', r[0]['pgver'])\njoined_path_wal = join(r[0]['dd'], 'pg_wal' if r[0]['pgver'] >= 100000 else 'pg_xlog')\nwal_stat = stat(joined_path_wal)\nif wal_stat.st_dev == dd_stat.st_dev:\n    pass                                # no new info, same device\nelse:\n    du = disk_usage(joined_path_wal)\n    ret_list.append(['pg_wal', joined_path_wal, du.total, du.used, du.free, du.percent])\n\n# add user created tablespaces if any\nsql_tablespaces = """\n    select spcname as name, pg_catalog.pg_tablespace_location(oid) as location\n    from pg_catalog.pg_tablespace where not spcname like any(array[E'pg\\\\_%'])"""\nfor row in plpy.cursor(sql_tablespaces):\n    du = disk_usage(row['location'])\n    ret_list.append([row['name'], row['location'], du.total, du.used, du.free, du.percent])\nreturn ret_list\n\n$FUNCTION$;\n\nGRANT EXECUTE ON FUNCTION get_psutil_disk() TO pgwatch2;\nCOMMENT ON FUNCTION get_psutil_disk() IS 'created for pgwatch2';\n\n	\N	t	t	2020-05-05 17:15:29.309165-07	f	f	{"prometheus_all_gauge_columns": true}	
136	psutil_disk_io_total	9.1	\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  read_count,\n  write_count,\n  read_bytes,\n  write_bytes\nfrom\n  get_psutil_disk_io_total();\n	\N	t	f	2020-05-05 17:15:29.309927-07	f	f	{"prometheus_all_gauge_columns": true}	
137	get_psutil_disk_io_total	9.1	\n\n/* Pre-requisites: PL/Pythonu and "psutil" Python package (e.g. pip install psutil) */\nCREATE EXTENSION IF NOT EXISTS plpython3u; /* NB! "plpython3u" might need changing to "plpythonu" (Python 2) everywhere for older OS-es */\n\nCREATE OR REPLACE FUNCTION get_psutil_disk_io_total(\n\tOUT read_count float8, OUT write_count float8, OUT read_bytes float8, OUT write_bytes float8\n)\n LANGUAGE plpython3u\n SECURITY DEFINER\nAS $FUNCTION$\nfrom psutil import disk_io_counters\ndc = disk_io_counters(perdisk=False)\nreturn dc.read_count, dc.write_count, dc.read_bytes, dc.write_bytes\n$FUNCTION$;\n\nGRANT EXECUTE ON FUNCTION get_psutil_disk_io_total() TO pgwatch2;\nCOMMENT ON FUNCTION get_psutil_disk_io_total() IS 'created for pgwatch2';\n\n	\N	t	t	2020-05-05 17:15:29.310551-07	f	f	{"prometheus_all_gauge_columns": true}	
138	archiver	9.4	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  archived_count,\n  failed_count,\n  case when coalesce(last_failed_time, '1970-01-01'::timestamptz) > coalesce(last_archived_time, '1970-01-01'::timestamptz) then 1 else 0 end as is_failing_int,\n  extract(epoch from now() - last_failed_time)::int8 as seconds_since_last_failure\nfrom\n  pg_stat_archiver\nwhere\n  current_setting('archive_mode') in ('on', 'always');\n	\N	t	f	2020-05-05 17:15:29.311139-07	f	f	{"prometheus_gauge_columns": ["is_failing_int", "seconds_since_last_failure"]}	
139	get_wal_size	9.0	\n\nCREATE OR REPLACE FUNCTION get_wal_size() RETURNS int8 AS\n$$\nselect sum((pg_stat_file('pg_xlog/'||f)).size)::int8 from (select pg_ls_dir('pg_xlog') f) ls\n$$ LANGUAGE sql VOLATILE SECURITY DEFINER;\n\nGRANT EXECUTE ON FUNCTION get_wal_size() TO pgwatch2;\nCOMMENT ON FUNCTION get_wal_size() IS 'created for pgwatch2';\n\n	for internal usage - when connecting user is marked as superuser then the daemon will automatically try to create the needed helpers on the monitored db	t	t	2020-05-05 17:15:29.311651-07	f	f	\N	
140	get_wal_size	10	\n\nCREATE OR REPLACE FUNCTION get_wal_size() RETURNS int8 AS\n$$\nselect (sum((pg_stat_file('pg_wal/' || name)).size))::int8 from pg_ls_waldir()\n$$ LANGUAGE sql VOLATILE SECURITY DEFINER;\n\nGRANT EXECUTE ON FUNCTION get_wal_size() TO pgwatch2;\nCOMMENT ON FUNCTION get_wal_size() IS 'created for pgwatch2';\n\n	for internal usage - when connecting user is marked as superuser then the daemon will automatically try to create the needed helpers on the monitored db	t	t	2020-05-05 17:15:29.312181-07	f	f	\N	
141	wal_size	9.0	\nselect\n    (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n    get_wal_size() as wal_size_b;\n	\N	t	f	2020-05-05 17:15:29.31261-07	f	f	\N	\nselect\n    (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n    sum((pg_stat_file('pg_xlog/'||f)).size)::int8 as wal_size_b from (select pg_ls_dir('pg_xlog') f) ls;\n
142	wal_size	10	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  get_wal_size() as wal_size_b;\n	\N	t	f	2020-05-05 17:15:29.313113-07	f	f	{"prometheus_all_gauge_columns": true}	\n/* NB! If using not a real superuser but a role with "pg_monitor" grant then below execute grant is needed:\n  EXECUTE on FUNCTION pg_stat_file(text) to pgwatch2;\n*/\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n   (sum((pg_stat_file('pg_wal/' || name)).size))::int8 as wal_size_b\nfrom pg_ls_waldir();\n
143	wal_receiver	9.2	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  pg_xlog_location_diff(pg_last_xlog_receive_location(), pg_last_xlog_replay_location()) as replay_lag_b,\n  extract(epoch from (now() - pg_last_xact_replay_timestamp()))::int8 as last_replay_s;\n	\N	t	f	2020-05-05 17:15:29.313606-07	f	t	{"prometheus_all_gauge_columns": true}	
144	wal_receiver	10	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  pg_wal_lsn_diff(pg_last_wal_receive_lsn(), pg_last_wal_replay_lsn()) as replay_lag_b,\n  extract(epoch from (now() - pg_last_xact_replay_timestamp()))::int8 as last_replay_s;\n	\N	t	f	2020-05-05 17:15:29.314147-07	f	t	{"prometheus_all_gauge_columns": true}	
145	get_stat_replication	9.2	\n\nCREATE OR REPLACE FUNCTION get_stat_replication() RETURNS SETOF pg_stat_replication AS\n$$\n  select * from pg_stat_replication\n$$ LANGUAGE sql VOLATILE SECURITY DEFINER;\n\nGRANT EXECUTE ON FUNCTION get_stat_replication() TO pgwatch2;\nCOMMENT ON FUNCTION get_stat_replication() IS 'created for pgwatch2';\n\n	for internal usage - when connecting user is marked as superuser then the daemon will automatically try to create the needed helpers on the monitored db	t	t	2020-05-05 17:15:29.314637-07	f	f	\N	
146	settings	9.0	\nwith qs as (\n  select name, setting from pg_settings\n)\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  current_setting('server_version') as server_version,\n  current_setting('server_version_num')::int8 as server_version_num,\n  current_setting('block_size')::int as block_size,\n  current_setting('max_connections')::int as max_connections,\n  current_setting('hot_standby') as hot_standby,\n  (select setting from qs where name = 'hot_standby_feedback') as hot_standby_feedback,\n  current_setting('fsync') as fsync,\n  current_setting('full_page_writes') as full_page_writes,\n  current_setting('synchronous_commit') as synchronous_commit,\n  (select setting from qs where name = 'wal_compression') as wal_compression,\n  (select setting from qs where name = 'wal_log_hints') as wal_log_hints,\n  (select setting from qs where name = 'synchronous_standby_names') as synchronous_standby_names,\n  current_setting('shared_buffers') as shared_buffers,\n  current_setting('work_mem') as work_mem,\n  current_setting('maintenance_work_mem') as maintenance_work_mem,\n  current_setting('effective_cache_size') as effective_cache_size,\n  (select setting::int8 from qs where name = 'default_statistics_target') as default_statistics_target,\n  (select setting::float8 from qs where name = 'random_page_cost') as random_page_cost,\n  pg_size_pretty(((select setting::int8 from qs where name = 'min_wal_size') * 1024^2)::int8) as min_wal_size,\n  pg_size_pretty(((select setting::int8 from qs where name = 'max_wal_size') * 1024^2)::int8) as max_wal_size,\n  (select setting from qs where name = 'checkpoint_segments') as checkpoint_segments,\n  current_setting('checkpoint_timeout') as checkpoint_timeout,\n  current_setting('checkpoint_completion_target') as checkpoint_completion_target,\n  (select setting::int8 from qs where name = 'max_worker_processes') as max_worker_processes,\n  (select setting::int8 from qs where name = 'max_parallel_workers') as max_parallel_workers,\n  (select setting::int8 from qs where name = 'max_parallel_workers_per_gather') as max_parallel_workers_per_gather,\n  (select case when setting = 'on' then 1 else 0 end from qs where name = 'jit') as jit,\n  (select case when setting = 'on' then 1 else 0 end from qs where name = 'ssl') as ssl,\n  current_setting('statement_timeout') as statement_timeout,\n  current_setting('deadlock_timeout') as deadlock_timeout,\n  (select setting from qs where name = 'data_checksums') as data_checksums,\n  (select setting::int8 from qs where name = 'max_connections') as max_connections,\n  (select setting::int8 from qs where name = 'max_wal_senders') as max_wal_senders,\n  (select setting::int8 from qs where name = 'max_replication_slots') as max_replication_slots,\n  (select setting::int8 from qs where name = 'max_prepared_transactions') as max_prepared_transactions,\n  (select setting::int8 from qs where name = 'lock_timeout') || ' (ms)' as lock_timeout,\n  (select setting from qs where name = 'archive_mode') as archive_mode,\n  (select setting from qs where name = 'archive_command') as archive_command,\n  current_setting('archive_timeout') as archive_timeout,\n  (select setting from qs where name = 'shared_preload_libraries') as shared_preload_libraries,\n  (select setting from qs where name = 'listen_addresses') as listen_addresses,\n  (select setting from qs where name = 'ssl') as ssl,\n  (select setting from qs where name = 'autovacuum') as autovacuum,\n  (select setting::int8 from qs where name = 'autovacuum_max_workers') as autovacuum_max_workers,\n  (select setting::float8 from qs where name = 'autovacuum_vacuum_scale_factor') as autovacuum_vacuum_scale_factor,\n  (select setting::float8 from qs where name = 'autovacuum_vacuum_threshold') as autovacuum_vacuum_threshold,\n  (select setting::float8 from qs where name = 'autovacuum_analyze_scale_factor') as autovacuum_analyze_scale_factor,\n  (select setting::float8 from qs where name = 'autovacuum_analyze_threshold') as autovacuum_analyze_scale_factor\n;\n	\N	t	f	2020-05-05 17:15:29.315322-07	f	f	{"prometheus_all_gauge_columns": true}	
148	stat_activity_realtime	9.2	\nSELECT\n    (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n    pid as tag_pid,\n    usename::text AS user,\n    application_name AS appname,\n    coalesce(client_addr::text, 'local') AS ip,\n    extract(epoch FROM (now() - query_start))::int AS duration_s,\n    waiting::int,\n    case when sa.waiting then\n        (select array_to_string((select array_agg(distinct b.pid order by b.pid) from pg_locks b join pg_locks l on l.database = b.database and l.relation = b.relation\n           where l.pid = sa.pid and b.pid != l.pid and b.granted and not l.granted), ','))\n        else\n            null\n    end as blocking_pids,\n    ltrim(regexp_replace(query, E'[ \\\\t\\\\n\\\\r]+' , ' ', 'g'))::varchar(300) AS query\nFROM\n    pg_stat_activity sa\nWHERE\n    state != 'idle'\n    AND pid != pg_backend_pid()\n    AND datname = current_database()\n    AND now() - query_start > '500ms'::interval\nORDER BY\n    now() - query_start DESC\nLIMIT 25;\n	\N	t	f	2020-05-05 17:15:29.316671-07	f	f	{"prometheus_all_gauge_columns": true}	
149	stat_activity_realtime	9.6	\nSELECT\n    (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n    pid as tag_pid,\n    usename::text AS user,\n    application_name AS appname,\n    coalesce(client_addr::text, 'local') AS ip,\n    extract(epoch FROM (now() - query_start))::int AS duration_s,\n    (wait_event_type IS NOT NULL)::int AS waiting,\n    array_to_string(pg_blocking_pids(pid), ',') as blocking_pids,\n    ltrim(regexp_replace(query, E'[ \\\\t\\\\n\\\\r]+' , ' ', 'g'))::varchar(300) AS query\nFROM\n    pg_stat_activity\nWHERE\n  state != 'idle'\n  AND pid != pg_backend_pid()\n  AND datname = current_database()\n  AND now() - query_start > '500ms'::interval\nORDER BY\n  now() - query_start DESC\nLIMIT 25;\n	\N	t	f	2020-05-05 17:15:29.317259-07	f	f	{"prometheus_all_gauge_columns": true}	
150	stat_activity_realtime	10	\nSELECT\n    (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n    pid as tag_pid,\n    usename::text AS user,\n    application_name AS appname,\n    coalesce(client_addr::text, 'local') AS ip,\n    extract(epoch FROM (now() - query_start))::int AS duration_s,\n    (coalesce(wait_event_type, '') IN ('LWLockNamed', 'Lock', 'BufferPin'))::int AS waiting,\n    array_to_string(pg_blocking_pids(pid), ',') as blocking_pids,\n    ltrim(regexp_replace(query, E'[ \\\\t\\\\n\\\\r]+' , ' ', 'g'))::varchar(300) AS query\nFROM\n    pg_stat_activity\nWHERE\n  state != 'idle'\n  AND backend_type IN ('client backend', 'autovacuum worker')\n  AND pid != pg_backend_pid()\n  AND datname = current_database()\n  AND now() - query_start > '500ms'::interval\nORDER BY\n  now() - query_start DESC\nLIMIT 25;\n	\N	t	f	2020-05-05 17:15:29.31779-07	f	f	{"prometheus_all_gauge_columns": true}	
151	reco_add_index	9.1	\n/* assumes the pg_qualstats extension and superuser or select grants on pg_qualstats_indexes_ddl view */\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  'create_index'::text as tag_reco_topic,\n  quote_ident(nspname::text)||'.'||quote_ident(relid::text) as tag_object_name,\n  ddl as recommendation,\n  ('qual execution count: '|| execution_count)::text as extra_info\nfrom\n  pg_qualstats_indexes_ddl\norder by\n  execution_count desc\nlimit 25;\n	\N	t	f	2020-05-05 17:15:29.318291-07	t	f	{"prometheus_all_gauge_columns": true}	
152	reco_default_public_schema	9.1	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  'default_public_schema_privs'::text as tag_reco_topic,\n  nspname::text as tag_object_name,\n  'REVOKE CREATE ON SCHEMA public FROM PUBLIC;'::text as recommendation,\n  'only authorized users should be allowed to create new objects'::text as extra_info\nfrom\n  pg_namespace\nwhere\n  nspname = 'public'\n  and nspacl::text ~ E'[,\\\\{]+=U?C/'\n;\n	\N	t	f	2020-05-05 17:15:29.318769-07	t	f	{"prometheus_all_gauge_columns": true}	
153	reco_drop_index	9.0	\n/* assumes the pg_qualstats extension */\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  'drop_index'::text as tag_reco_topic,\n  quote_ident(schemaname)||'.'||quote_ident(indexrelname) as tag_object_name,\n  ('DROP INDEX ' || quote_ident(schemaname)||'.'||quote_ident(indexrelname) || ';')::text as recommendation,\n  'NB! Before dropping make sure to also check replica pg_stat_user_indexes.idx_scan count if using them for queries'::text as extra_info\nfrom\n  pg_stat_user_indexes\n  join\n  pg_index using (indexrelid)\nwhere\n  idx_scan = 0\n  and ((pg_relation_size(indexrelid)::numeric / (pg_database_size(current_database()))) > 0.005 /* 0.5% DB size threshold */\n    or indisvalid)\n  and not indisprimary\n;\n	\N	t	f	2020-05-05 17:15:29.319204-07	t	f	{"prometheus_all_gauge_columns": true}	
154	reco_drop_index	9.4	\n/* assumes the pg_qualstats extension */\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  'drop_index'::text as tag_reco_topic,\n  quote_ident(schemaname)||'.'||quote_ident(indexrelname) as tag_object_name,\n  ('DROP INDEX ' || quote_ident(schemaname)||'.'||quote_ident(indexrelname) || ';')::text as recommendation,\n  'NB! Make sure to also check replica pg_stat_user_indexes.idx_scan count if using them for queries'::text as extra_info\nfrom\n  pg_stat_user_indexes\n  join\n  pg_index using (indexrelid)\nwhere\n  idx_scan = 0\n  and ((pg_relation_size(indexrelid)::numeric / (pg_database_size(current_database()))) > 0.005 /* 0.5% DB size threshold */\n    or indisvalid)\n  and not indisprimary\n  and not indisreplident\n;\n	\N	t	f	2020-05-05 17:15:29.319619-07	t	f	{"prometheus_all_gauge_columns": true}	
155	reco_nested_views	9.1	\nWITH RECURSIVE views AS (\n   -- get the directly depending views\n   SELECT v.oid::regclass AS view,\n          format('%s.%s', quote_ident(n.nspname), quote_ident(v.relname)) as full_name,\n          1 AS level\n   FROM pg_depend AS d\n      JOIN pg_rewrite AS r\n         ON r.oid = d.objid\n      JOIN pg_class AS v\n         ON v.oid = r.ev_class\n      JOIN pg_namespace AS n\n         ON n.oid = v.relnamespace\n   WHERE v.relkind = 'v'\n     AND NOT n.nspname = ANY(array['information_schema', E'pg\\\\_%'])\n     AND NOT v.relname LIKE E'pg\\\\_%'\n     AND d.classid = 'pg_rewrite'::regclass\n     AND d.refclassid = 'pg_class'::regclass\n     AND d.deptype = 'n'\nUNION ALL\n   -- add the views that depend on these\n   SELECT v.oid::regclass,\n          format('%s.%s', quote_ident(n.nspname), quote_ident(v.relname)) as full_name,\n          views.level + 1\n   FROM views\n      JOIN pg_depend AS d\n         ON d.refobjid = views.view\n      JOIN pg_rewrite AS r\n         ON r.oid = d.objid\n      JOIN pg_class AS v\n         ON v.oid = r.ev_class\n      JOIN pg_namespace AS n\n         ON n.oid = v.relnamespace\n   WHERE v.relkind = 'v'\n     AND NOT n.nspname = ANY(array['information_schema', E'pg\\\\_%'])\n     AND d.classid = 'pg_rewrite'::regclass\n     AND d.refclassid = 'pg_class'::regclass\n     AND d.deptype = 'n'\n     AND v.oid <> views.view  -- avoid loop\n)\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  'overly_nested_views'::text AS tag_reco_topic,\n  full_name::text as tag_object_name,\n  'overly nested views can affect performance'::text recommendation,\n  'nesting_depth: ' || coalesce (max(level)::text, '-') AS extra_info\nFROM views\nGROUP BY 1, 2, 3\nHAVING max(level) > 3\nORDER BY max(level) DESC, full_name::text;\n	\N	t	f	2020-05-05 17:15:29.320106-07	t	f	{"prometheus_all_gauge_columns": true}	
156	reco_sprocs_wo_search_path	9.1	\nwith q_sprocs as (\nselect\n  format('%s.%s', quote_ident(nspname), quote_ident(proname)) as sproc_name,\n  'alter function ' || proname || '(' || pg_get_function_arguments(p.oid) || ') set search_path = X;' as fix_sql\nfrom\n  pg_proc p\n  join pg_namespace n on n.oid = p.pronamespace\n  where prosecdef and not 'search_path' = ANY(coalesce(proconfig, '{}'::text[]))\n  and not pg_catalog.obj_description(p.oid, 'pg_proc') ~ 'pgwatch2'\n)\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  'sprocs_wo_search_path'::text as tag_reco_topic,\n  sproc_name::text as tag_object_name,\n  fix_sql::text as recommendation,\n  'functions without fixed search_path can be potentially abused by malicious users if used objects are not fully qualified'::text as extra_info\nfrom\n  q_sprocs\norder by\n   tag_object_name, extra_info;\n	\N	t	f	2020-05-05 17:15:29.320617-07	t	f	{"prometheus_all_gauge_columns": true}	
157	reco_superusers	9.1	\n/* reco_* metrics have special handling - all results are stored actually under one 'recommendations' metric  and\n following text columns are expected:  reco_topic, object_name, recommendation, extra_info.\n*/\nwith q_su as (\n  select count(*) from pg_roles where rolcanlogin and rolsuper\n),\nq_total as (\n  select count(*) from pg_roles where rolcanlogin\n)\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  'superuser_count'::text as tag_reco_topic,\n  '-'::text as tag_object_name,\n  'too many superusers detected - review recommended'::text as recommendation,\n  format('%s active superusers, %s total active users', q_su.count, q_total.count) as extra_info\nfrom\n  q_su, q_total\nwhere\n  q_su.count >= 10\n;\n	\N	t	f	2020-05-05 17:15:29.321169-07	t	f	{"prometheus_all_gauge_columns": true}	
158	show_plans_realtime	9.0	\n/* assumes pg_show_plans extension */\nselect\n  max((extract(epoch from now()) * 1e9)::int8) as epoch_ns,\n  max(extract(epoch from now() - query_start))::int as max_s,\n  avg(extract(epoch from now() - query_start))::int as avg_s,\n  count(*),\n  array_to_string(array_agg(distinct usename order by usename), ',') as "users",\n  max(md5(plan)) as tag_hash, /* needed for influx */\n  plan,\n  max(query) as query\nfrom\n  pg_show_plans p\n  join\n  pg_stat_activity a\n    using (pid)\nwhere\n  p.pid != pg_backend_pid()\n  and datname = current_database()\n  and now() - query_start > '1s'::interval\ngroup by\n  plan\norder by\n  max_s desc\nlimit\n  10\n;\n	\N	t	f	2020-05-05 17:15:29.321664-07	f	f	{"prometheus_all_gauge_columns": true}	
159	show_plans_realtime	10	\n/* assumes pg_show_plans extension */\nselect\n  max((extract(epoch from now()) * 1e9)::int8) as epoch_ns,\n  max(extract(epoch from now() - query_start))::int as max_s,\n  avg(extract(epoch from now() - query_start))::int as avg_s,\n  count(*),\n  array_to_string(array_agg(distinct usename order by usename), ',') as "users",\n  max(md5(plan)) as tag_hash, /* needed for influx */\n  plan,\n  max(query) as query\nfrom\n  pg_show_plans p\n  join\n  pg_stat_activity a\n    using (pid)\nwhere\n  p.pid != pg_backend_pid()\n  and datname = current_database()\n  and now() - query_start > '1s'::interval\n  and backend_type = 'client backend'\ngroup by\n  plan\norder by\n  max_s desc\nlimit\n  10\n;\n	\N	t	f	2020-05-05 17:15:29.322159-07	f	f	{"prometheus_all_gauge_columns": true}	
160	get_smart_health_per_device	9.1	\nCREATE EXTENSION IF NOT EXISTS plpython3u;\n/*\n  A wrapper around smartmontools to verify disk SMART health for all disk devices. 0 = SMART check PASSED.\n  NB! This helper is always meant to be tested / adjusted to make sure all disk are detected etc.\n  Most likely smartctl privileges must be escalated to give postgres access: sudo chmod u+s /usr/local/sbin/smartctl\n*/\nCREATE OR REPLACE FUNCTION get_smart_health_per_device(OUT device text, OUT retcode int) RETURNS SETOF record AS\n$$\n\nimport subprocess\nret_list = []\n\n#disk_detect_cmd='smartctl --scan | cut -d " " -f3 | grep mega' # for Lenovo ServerRAID M1210\ndisk_detect_cmd='lsblk -io KNAME,TYPE | grep '' disk'' | cut -d " " -f1 | sort'\np = subprocess.run(disk_detect_cmd, stdout=subprocess.PIPE, encoding='utf-8', shell=True)\nif p.returncode != 0:\n    return ret_list\ndisks = p.stdout.splitlines()\n\nfor disk in disks:\n    # health_cmd = 'smartctl -d $disk -a -q silent /dev/sda' % disk    # for Lenovo ServerRAID M1210 members\n    health_cmd = 'smartctl  -a -q silent /dev/%s' % disk\n    p = subprocess.run(health_cmd, stdout=subprocess.PIPE, encoding='utf-8', shell=True)\n    ret_list.append((disk, p.returncode))\n\nreturn ret_list\n\n$$ LANGUAGE plpython3u VOLATILE;\n\nGRANT EXECUTE ON FUNCTION get_smart_health_per_device() TO pgwatch2;\n\nCOMMENT ON FUNCTION get_smart_health_per_device() is 'created for pgwatch2';\n	\N	t	t	2020-05-05 17:15:29.32273-07	f	f	{"prometheus_all_gauge_columns": true}	
161	smart_health_per_disk	9.1	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  device as tag_device,\n  retcode\nfrom\n  get_smart_health_per_device();\n	\N	t	f	2020-05-05 17:15:29.323172-07	f	f	{"prometheus_all_gauge_columns": true}	
162	server_log_event_counts	9.0	\n/* dummy placeholder - special handling in code */\n	\N	t	f	2020-05-05 17:15:29.323585-07	f	f	{"prometheus_all_gauge_columns": true}	
163	get_backup_age_walg	9.1	\nCREATE EXTENSION IF NOT EXISTS plpython3u;\n/*\n  Gets age of last successful WAL-G backup via "wal-g backup-list" timestamp. Returns 0 retcode on success.\n  Expects .wal-g.json is correctly configured with all necessary credentials and "jq" tool is installed on the DB server.\n*/\nCREATE OR REPLACE FUNCTION get_backup_age_walg(OUT retcode int, OUT backup_age_seconds int, OUT message text) AS\n$$\nimport subprocess\nretcode=1\nbackup_age_seconds=1000000\nmessage=''\n\n# get latest wal-g backup timestamp\nwalg_last_backup_cmd="""wal-g backup-list --json | jq -r '.[0].time'"""\np = subprocess.run(walg_last_backup_cmd, stdout=subprocess.PIPE, encoding='utf-8', shell=True)\nif p.returncode != 0:\n    # plpy.notice("p.stdout: " + str(p.stderr) + str(p.stderr))\n    return p.returncode, backup_age_seconds, 'Not OK. Failed on wal-g backup-list call'\n\n# plpy.notice("last_tz: " + last_tz)\nlast_tz=p.stdout.rstrip('\\n\\r')\n\n# get seconds since last backup from WAL-G timestamp in format '2020-01-22T17:50:51Z'\ntry:\n    plan = plpy.prepare("SELECT extract(epoch from now() - $1::timestamptz)::int AS backup_age_seconds;", ["text"])\n    rv = plpy.execute(plan, [last_tz])\nexcept Exception as e:\n    return retcode, backup_age_seconds, 'Not OK. Failed to convert WAL-G backup timestamp to seconds'\nelse:\n    backup_age_seconds = rv[0]["backup_age_seconds"]\n    return 0, backup_age_seconds, 'OK. Last backup age in seconds: %s' % backup_age_seconds\n\n$$ LANGUAGE plpython3u VOLATILE;\n\n/* contacting S3 could be laggy depending on location */\nALTER FUNCTION get_backup_age_walg() SET statement_timeout TO '30s';\n\nGRANT EXECUTE ON FUNCTION get_backup_age_walg() TO pgwatch2;\n\nCOMMENT ON FUNCTION get_backup_age_walg() is 'created for pgwatch2';\n\n	for internal usage - when connecting user is marked as superuser then the daemon will automatically try to create the needed helpers on the monitored db	t	t	2020-05-05 17:15:29.324059-07	f	f	\N	
164	backup_age_walg	9.1	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  retcode,\n  backup_age_seconds,\n  message\nfrom\n  get_backup_age_walg()\n;\n	\N	t	f	2020-05-05 17:15:29.324464-07	f	f	{"prometheus_all_gauge_columns": true}	
165	get_backup_age_pgbackrest	9.1	\n\nCREATE EXTENSION IF NOT EXISTS plpython3u;\n/*\n  Gets age of last successful pgBackRest backup via "pgbackrest --output=json info" unix timestamp. Returns 0 retcode on success.\n  Expects pgBackRest is correctly configured on monitored DB and "jq" tool is installed on the DB server.\n*/\nCREATE OR REPLACE FUNCTION get_backup_age_pgbackrest(OUT retcode int, OUT backup_age_seconds int, OUT message text) AS\n$$\nimport subprocess\nretcode=1\nbackup_age_seconds=1000000\nmessage=''\n\n# get latest wal-g backup timestamp\nwalg_last_backup_cmd="""pgbackrest --output=json info | jq '.[0] | .backup[-1] | .timestamp.stop'"""\np = subprocess.run(walg_last_backup_cmd, stdout=subprocess.PIPE, encoding='utf-8', shell=True)\nif p.returncode != 0:\n    # plpy.notice("p.stdout: " + str(p.stderr) + str(p.stderr))\n    return p.returncode, backup_age_seconds, 'Not OK. Failed on "pgbackrest info" call'\n\nlast_backup_stop_epoch=p.stdout.rstrip('\\n\\r')\n\ntry:\n    plan = plpy.prepare("SELECT (extract(epoch from now()) - $1)::int8 AS backup_age_seconds;", ["int8"])\n    rv = plpy.execute(plan, [last_backup_stop_epoch])\nexcept Exception as e:\n    return retcode, backup_age_seconds, 'Not OK. Failed to extract seconds difference via Postgres'\nelse:\n    backup_age_seconds = rv[0]["backup_age_seconds"]\n    return 0, backup_age_seconds, 'OK. Last backup age in seconds: %s' % backup_age_seconds\n\n$$ LANGUAGE plpython3u VOLATILE;\n\n/* contacting S3 could be laggy depending on location */\nALTER FUNCTION get_backup_age_pgbackrest() SET statement_timeout TO '30s';\n\nGRANT EXECUTE ON FUNCTION get_backup_age_pgbackrest() TO pgwatch2;\n\nCOMMENT ON FUNCTION get_backup_age_pgbackrest() is 'created for pgwatch2';\n\n	for internal usage - when connecting user is marked as superuser then the daemon will automatically try to create the needed helpers on the monitored db	t	t	2020-05-05 17:15:29.324926-07	f	f	\N	
166	backup_age_pgbackrest	9.1	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  retcode,\n  backup_age_seconds,\n  message\nfrom\n  get_backup_age_pgbackrest()\n;\n	\N	t	f	2020-05-05 17:15:29.325377-07	f	f	{"prometheus_all_gauge_columns": true}	
167	logical_subscriptions	10	\nwith q_sr as (\n  select * from pg_subscription_rel\n)\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  subname::text as tag_subname,\n  subenabled,\n  (select count(*) from q_sr where srsubid = oid) as relcount,\n  (select count(*) from q_sr where srsubid = oid and srsubstate = 'i') as state_i,\n  (select count(*) from q_sr where srsubid = oid and srsubstate = 'd') as state_d,\n  (select count(*) from q_sr where srsubid = oid and srsubstate = 's') as state_s,\n  (select count(*) from q_sr where srsubid = oid and srsubstate = 'r') as state_r\nfrom\n  pg_subscription\nwhere\n  subdbid = (select oid from pg_database where datname = current_database())\n;\n	\N	t	f	2020-05-05 17:15:29.325796-07	f	f	{"prometheus_all_gauge_columns": true}	
\.


--
-- Name: metric_m_id_seq; Type: SEQUENCE SET; Schema: pgwatch2; Owner: pgwatch2
--

SELECT pg_catalog.setval('pgwatch2.metric_m_id_seq', 167, true);


--
-- PostgreSQL database dump complete
--


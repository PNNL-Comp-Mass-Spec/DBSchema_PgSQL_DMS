--
-- PostgreSQL database dump
--

-- Dumped from database version 12.2
-- Dumped by pg_dump version 12.1

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Data for Name: metric; Type: TABLE DATA; Schema: pgwatch2; Owner: pgwatch2
--

COPY pgwatch2.metric (m_id, m_name, m_pg_version_from, m_sql, m_comment, m_is_active, m_is_helper, m_last_modified_on, m_master_only, m_standby_only, m_column_attrs, m_sql_su) FROM stdin;
1	backends	9.0	\nwith sa_snapshot as (\n  select * from get_stat_activity() where not current_query like 'autovacuum:%'\n)\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  (select count(*) from sa_snapshot) as total,\n  (select count(*) from sa_snapshot where current_query != '<IDLE>') as active,\n  (select count(*) from sa_snapshot where current_query = '<IDLE>') as idle,\n  (select count(*) from sa_snapshot where current_query = '<IDLE> in transaction') as idleintransaction,\n  (select count(*) from sa_snapshot where waiting) as waiting,\n  (select extract(epoch from (now() - backend_start))::int\n    from sa_snapshot order by backend_start limit 1) as longest_session_seconds,\n  (select extract(epoch from (now() - xact_start))::int\n    from sa_snapshot where xact_start is not null order by xact_start limit 1) as longest_tx_seconds,\n  (select extract(epoch from (now() - xact_start))::int\n   from get_stat_activity() where current_query like 'autovacuum:%' order by xact_start limit 1) as longest_autovacuum_seconds,\n  (select extract(epoch from max(now() - query_start))::int\n    from sa_snapshot where current_query != '<IDLE>') as longest_query_seconds;\n	\N	t	f	2019-10-04 22:09:34.746933-07	f	f	{"prometheus_all_gauge_columns": true}	\nwith sa_snapshot as (\n  select * from pg_stat_activity\n  where datname = current_database()\n  and not current_query like 'autovacuum:%'\n  and procpid != pg_backend_pid()\n)\nselect\n    (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n    (select count(*) from sa_snapshot) as total,\n    (select count(*) from sa_snapshot where current_query != '<IDLE>') as active,\n    (select count(*) from sa_snapshot where current_query = '<IDLE>') as idle,\n    (select count(*) from sa_snapshot where current_query = '<IDLE> in transaction') as idleintransaction,\n    (select count(*) from sa_snapshot where waiting) as waiting,\n    (select extract(epoch from (now() - backend_start))::int\n     from sa_snapshot order by backend_start limit 1) as longest_session_seconds,\n    (select extract(epoch from (now() - xact_start))::int\n     from sa_snapshot where xact_start is not null order by xact_start limit 1) as longest_tx_seconds,\n    (select extract(epoch from (now() - xact_start))::int\n     from pg_stat_activity where current_query like 'autovacuum:%' order by xact_start limit 1) as longest_autovacuum_seconds,\n    (select extract(epoch from max(now() - query_start))::int\n     from sa_snapshot where current_query != '<IDLE>') as longest_query_seconds;\n
2	backends	9.2	\nwith sa_snapshot as (\n  select * from get_stat_activity() where not query like 'autovacuum:%'\n)\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  (select count(*) from sa_snapshot) as total,\n  (select count(*) from sa_snapshot where state = 'active') as active,\n  (select count(*) from sa_snapshot where state = 'idle') as idle,\n  (select count(*) from sa_snapshot where state = 'idle in transaction') as idleintransaction,\n  (select count(*) from sa_snapshot where waiting) as waiting,\n  (select extract(epoch from (now() - backend_start))::int\n    from sa_snapshot order by backend_start limit 1) as longest_session_seconds,\n  (select extract(epoch from (now() - xact_start))::int\n    from sa_snapshot where xact_start is not null order by xact_start limit 1) as longest_tx_seconds,\n  (select extract(epoch from (now() - xact_start))::int\n   from get_stat_activity() where query like 'autovacuum:%' order by xact_start limit 1) as longest_autovacuum_seconds,\n  (select extract(epoch from max(now() - query_start))::int\n    from sa_snapshot where state = 'active') as longest_query_seconds;\n	\N	t	f	2019-10-04 22:09:34.749868-07	f	f	{"prometheus_all_gauge_columns": true}	\nwith sa_snapshot as (\n  select * from pg_stat_activity\n  where datname = current_database()\n  and not query like 'autovacuum:%'\n  and pid != pg_backend_pid()\n)\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  (select count(*) from sa_snapshot) as total,\n  (select count(*) from sa_snapshot where state = 'active') as active,\n  (select count(*) from sa_snapshot where state = 'idle') as idle,\n  (select count(*) from sa_snapshot where state = 'idle in transaction') as idleintransaction,\n  (select count(*) from sa_snapshot where waiting) as waiting,\n  (select extract(epoch from (now() - backend_start))::int\n    from sa_snapshot order by backend_start limit 1) as longest_session_seconds,\n  (select extract(epoch from (now() - xact_start))::int\n    from sa_snapshot where xact_start is not null order by xact_start limit 1) as longest_tx_seconds,\n  (select extract(epoch from (now() - xact_start))::int\n   from pg_stat_activity where query like 'autovacuum:%' order by xact_start limit 1) as longest_autovacuum_seconds,\n  (select extract(epoch from max(now() - query_start))::int\n    from sa_snapshot where state = 'active') as longest_query_seconds;\n
3	backends	9.4	\nwith sa_snapshot as (\n  select * from get_stat_activity() where not query like 'autovacuum:%'\n)\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  (select count(*) from sa_snapshot) as total,\n  (select count(*) from sa_snapshot where state = 'active') as active,\n  (select count(*) from sa_snapshot where state = 'idle') as idle,\n  (select count(*) from sa_snapshot where state = 'idle in transaction') as idleintransaction,\n  (select count(*) from sa_snapshot where waiting) as waiting,\n  (select extract(epoch from (now() - backend_start))::int\n    from sa_snapshot order by backend_start limit 1) as longest_session_seconds,\n  (select extract(epoch from (now() - xact_start))::int\n    from sa_snapshot where xact_start is not null order by xact_start limit 1) as longest_tx_seconds,\n  (select extract(epoch from (now() - xact_start))::int\n   from get_stat_activity() where query like 'autovacuum:%' order by xact_start limit 1) as longest_autovacuum_seconds,\n  (select extract(epoch from max(now() - query_start))::int\n    from sa_snapshot where state = 'active') as longest_query_seconds,\n  (select max(age(backend_xmin))::int8 from sa_snapshot) as max_xmin_age_tx;\n	\N	t	f	2019-10-04 22:09:34.750574-07	f	f	{"prometheus_all_gauge_columns": true}	\nwith sa_snapshot as (\n  select * from pg_stat_activity\n  where datname = current_database()\n  and not query like 'autovacuum:%'\n  and pid != pg_backend_pid()\n)\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  (select count(*) from sa_snapshot) as total,\n  (select count(*) from sa_snapshot where state = 'active') as active,\n  (select count(*) from sa_snapshot where state = 'idle') as idle,\n  (select count(*) from sa_snapshot where state = 'idle in transaction') as idleintransaction,\n  (select count(*) from sa_snapshot where waiting) as waiting,\n  (select extract(epoch from (now() - backend_start))::int\n    from sa_snapshot order by backend_start limit 1) as longest_session_seconds,\n  (select extract(epoch from (now() - xact_start))::int\n    from sa_snapshot where xact_start is not null order by xact_start limit 1) as longest_tx_seconds,\n  (select extract(epoch from (now() - xact_start))::int\n   from pg_stat_activity where query like 'autovacuum:%' order by xact_start limit 1) as longest_autovacuum_seconds,\n  (select extract(epoch from max(now() - query_start))::int\n    from sa_snapshot where state = 'active') as longest_query_seconds,\n  (select max(age(backend_xmin))::int8 from sa_snapshot) as max_xmin_age_tx;\n
4	backends	9.6	\nwith sa_snapshot as (\n  select * from get_stat_activity() where not query like 'autovacuum:%'\n)\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  (select count(*) from sa_snapshot) as total,\n  (select count(*) from sa_snapshot where state = 'active') as active,\n  (select count(*) from sa_snapshot where state = 'idle') as idle,\n  (select count(*) from sa_snapshot where state = 'idle in transaction') as idleintransaction,\n  (select count(*) from sa_snapshot where wait_event_type in ('LWLockNamed', 'Lock', 'BufferPin')) as waiting,\n  (select extract(epoch from (now() - backend_start))::int\n    from sa_snapshot order by backend_start limit 1) as longest_session_seconds,\n  (select extract(epoch from (now() - xact_start))::int\n    from sa_snapshot where xact_start is not null order by xact_start limit 1) as longest_tx_seconds,\n  (select extract(epoch from (now() - xact_start))::int\n   from get_stat_activity() where query like 'autovacuum:%' order by xact_start limit 1) as longest_autovacuum_seconds,\n  (select extract(epoch from max(now() - query_start))::int\n    from sa_snapshot where state = 'active') as longest_query_seconds,\n  (select max(age(backend_xmin))::int8 from sa_snapshot) as max_xmin_age_tx;\n	\N	t	f	2019-10-04 22:09:34.751162-07	f	f	{"prometheus_all_gauge_columns": true}	\nwith sa_snapshot as (\n  select * from pg_stat_activity\n  where datname = current_database()\n  and not query like 'autovacuum:%'\n  and pid != pg_backend_pid()\n)\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  (select count(*) from sa_snapshot) as total,\n  (select count(*) from sa_snapshot where state = 'active') as active,\n  (select count(*) from sa_snapshot where state = 'idle') as idle,\n  (select count(*) from sa_snapshot where state = 'idle in transaction') as idleintransaction,\n  (select count(*) from sa_snapshot where wait_event_type in ('LWLockNamed', 'Lock', 'BufferPin')) as waiting,\n  (select extract(epoch from (now() - backend_start))::int\n    from sa_snapshot order by backend_start limit 1) as longest_session_seconds,\n  (select extract(epoch from (now() - xact_start))::int\n    from sa_snapshot where xact_start is not null order by xact_start limit 1) as longest_tx_seconds,\n  (select extract(epoch from (now() - xact_start))::int\n   from pg_stat_activity where query like 'autovacuum:%' order by xact_start limit 1) as longest_autovacuum_seconds,\n  (select extract(epoch from max(now() - query_start))::int\n    from sa_snapshot where state = 'active') as longest_query_seconds,\n  (select max(age(backend_xmin))::int8 from sa_snapshot) as max_xmin_age_tx;\n
30	database_conflicts	9.2	\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  confl_tablespace,\n  confl_lock,\n  confl_snapshot,\n  confl_bufferpin,\n  confl_deadlock\nFROM\n  pg_stat_database_conflicts\nWHERE\n  datname = current_database();\n	\N	t	f	2019-10-04 22:09:34.76516-07	f	t	\N	
31	locks	9.0	\nWITH q_locks AS (\n  select\n    *\n  from\n    pg_locks\n  where\n    pid != pg_backend_pid()\n    and database = (select oid from pg_database where datname = current_database())\n)\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  locktypes AS tag_locktype,\n  coalesce((select count(*) FROM q_locks WHERE locktype = locktypes), 0) AS count\nFROM\n  unnest('{relation, extend, page, tuple, transactionid, virtualxid, object, userlock, advisory}'::text[]) locktypes;\n	\N	t	f	2019-10-04 22:09:34.765614-07	f	f	{"prometheus_gauge_columns": ["count"]}	
5	backends	10	\nwith sa_snapshot as (\n  select * from get_stat_activity()\n)\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  (select count(*) from sa_snapshot where backend_type = 'client backend') as total,\n  (select count(*) from sa_snapshot where backend_type = 'background worker') as background_workers,\n  (select count(*) from sa_snapshot where state = 'active' and backend_type = 'client backend') as active,\n  (select count(*) from sa_snapshot where state = 'idle' and backend_type = 'client backend') as idle,\n  (select count(*) from sa_snapshot where state = 'idle in transaction' and backend_type = 'client backend') as idleintransaction,\n  (select count(*) from sa_snapshot where wait_event_type in ('LWLock', 'Lock', 'BufferPin') and backend_type = 'client backend') as waiting,\n  (select extract(epoch from (now() - backend_start))::int\n    from sa_snapshot where backend_type = 'client backend' order by backend_start limit 1) as longest_session_seconds,\n  (select extract(epoch from (now() - xact_start))::int\n    from sa_snapshot where xact_start is not null and backend_type = 'client backend' order by xact_start limit 1) as longest_tx_seconds,\n  (select extract(epoch from (now() - xact_start))::int\n    from get_stat_activity() where backend_type = 'autovacuum worker' order by xact_start limit 1) as longest_autovacuum_seconds,\n  (select extract(epoch from max(now() - query_start))::int\n    from sa_snapshot where state = 'active' and backend_type = 'client backend') as longest_query_seconds,\n  (select max(age(backend_xmin))::int8 from sa_snapshot) as max_xmin_age_tx;\n	\N	t	f	2019-10-04 22:09:34.751737-07	f	f	{"prometheus_all_gauge_columns": true}	\nwith sa_snapshot as (\n  select * from pg_stat_activity\n  where pid != pg_backend_pid()\n  and datname = current_database()\n)\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  (select count(*) from sa_snapshot where backend_type = 'client backend') as total,\n  (select count(*) from sa_snapshot where backend_type = 'background worker') as background_workers,\n  (select count(*) from sa_snapshot where state = 'active' and backend_type = 'client backend') as active,\n  (select count(*) from sa_snapshot where state = 'idle' and backend_type = 'client backend') as idle,\n  (select count(*) from sa_snapshot where state = 'idle in transaction' and backend_type = 'client backend') as idleintransaction,\n  (select count(*) from sa_snapshot where wait_event_type in ('LWLock', 'Lock', 'BufferPin') and backend_type = 'client backend') as waiting,\n  (select extract(epoch from (now() - backend_start))::int\n    from sa_snapshot where backend_type = 'client backend' order by backend_start limit 1) as longest_session_seconds,\n  (select extract(epoch from (now() - xact_start))::int\n    from sa_snapshot where xact_start is not null and backend_type = 'client backend' order by xact_start limit 1) as longest_tx_seconds,\n  (select extract(epoch from (now() - xact_start))::int\n    from pg_stat_activity where backend_type = 'autovacuum worker' order by xact_start limit 1) as longest_autovacuum_seconds,\n  (select extract(epoch from max(now() - query_start))::int\n    from sa_snapshot where state = 'active' and backend_type = 'client backend') as longest_query_seconds,\n  (select max(age(backend_xmin))::int8 from sa_snapshot) as max_xmin_age_tx;\n
6	bgwriter	9.0	\nselect\n   (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n   checkpoints_timed,\n   checkpoints_req,\n   checkpoint_write_time,\n   checkpoint_sync_time,\n   buffers_checkpoint,\n   buffers_clean,\n   maxwritten_clean,\n   buffers_backend,\n   buffers_backend_fsync,\n   buffers_alloc\n from\n   pg_stat_bgwriter;\n	\N	t	f	2019-10-04 22:09:34.752766-07	t	f	\N	
7	cpu_load	9.0	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  round(load_1min::numeric, 2)::float as load_1min,\n  round(load_5min::numeric, 2)::float as load_5min,\n  round(load_15min::numeric, 2)::float as load_15min\nfrom\n  get_load_average();   -- needs the plpythonu proc from "metric_fetching_helpers" folder\n	\N	t	f	2019-10-04 22:09:34.75332-07	f	f	{"prometheus_all_gauge_columns": true}	
8	db_stats	9.0	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  numbackends,\n  xact_commit,\n  xact_rollback,\n  blks_read,\n  blks_hit,\n  tup_returned,\n  tup_fetched,\n  tup_inserted,\n  tup_updated,\n  tup_deleted,\n  conflicts,\n  temp_files,\n  temp_bytes,\n  deadlocks,\n  blk_read_time,\n  blk_write_time,\n  extract(epoch from (now() - pg_postmaster_start_time()))::int8 as postmaster_uptime_s\nfrom\n  pg_stat_database\nwhere\n  datname = current_database();\n	\N	t	f	2019-10-04 22:09:34.753772-07	f	f	{"prometheus_gauge_columns": ["numbackends", "postmaster_uptime_s", "backup_duration_s"]}	
9	db_stats	9.3	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  numbackends,\n  xact_commit,\n  xact_rollback,\n  blks_read,\n  blks_hit,\n  tup_returned,\n  tup_fetched,\n  tup_inserted,\n  tup_updated,\n  tup_deleted,\n  conflicts,\n  temp_files,\n  temp_bytes,\n  deadlocks,\n  blk_read_time,\n  blk_write_time,\n  extract(epoch from (now() - pg_postmaster_start_time()))::int8 as postmaster_uptime_s,\n  extract(epoch from (now() - pg_backup_start_time()))::int8 as backup_duration_s\nfrom\n  pg_stat_database\nwhere\n  datname = current_database();\n	\N	t	f	2019-10-04 22:09:34.754225-07	f	f	{"prometheus_gauge_columns": ["numbackends", "postmaster_uptime_s", "backup_duration_s"]}	
10	db_stats	12	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  numbackends,\n  xact_commit,\n  xact_rollback,\n  blks_read,\n  blks_hit,\n  tup_returned,\n  tup_fetched,\n  tup_inserted,\n  tup_updated,\n  tup_deleted,\n  conflicts,\n  temp_files,\n  temp_bytes,\n  deadlocks,\n  blk_read_time,\n  blk_write_time,\n  extract(epoch from (now() - pg_postmaster_start_time()))::int8 as postmaster_uptime_s,\n  extract(epoch from (now() - pg_backup_start_time()))::int8 as backup_duration_s,\n  checksum_failures,\n  extract(epoch from (now() - checksum_last_failure))::int8 as checksum_last_failure_s\nfrom\n  pg_stat_database\nwhere\n  datname = current_database();\n	\N	t	f	2019-10-04 22:09:34.754611-07	f	f	{"prometheus_gauge_columns": ["numbackends", "postmaster_uptime_s", "backup_duration_s", "checksum_last_failure_s"]}	
11	db_size	9.0	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  pg_database_size(current_database()) as size_b;\n	\N	t	f	2019-10-04 22:09:34.755075-07	f	f	{"prometheus_all_gauge_columns": true}	
12	index_stats	9.0	\nWITH q_locked_rels AS (\n  select relation from pg_locks where mode = 'AccessExclusiveLock' and granted\n)\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  schemaname::text as tag_schema,\n  indexrelname::text as tag_index_name,\n  quote_ident(schemaname)||'.'||quote_ident(indexrelname) as tag_index_full_name,\n  relname::text as tag_table_name,\n  quote_ident(schemaname)||'.'||quote_ident(relname) as tag_table_full_name,\n  coalesce(idx_scan, 0) as idx_scan,\n  coalesce(idx_tup_read, 0) as idx_tup_read,\n  coalesce(idx_tup_fetch, 0) as idx_tup_fetch,\n  coalesce(pg_relation_size(indexrelid), 0) as index_size_b,\n  quote_ident(schemaname)||'.'||quote_ident(sui.indexrelname) as index_full_name_val,\n  md5(regexp_replace(replace(pg_get_indexdef(sui.indexrelid),indexrelname,'X'), '^CREATE UNIQUE','CREATE')) as tag_index_def_hash,\n  regexp_replace(replace(pg_get_indexdef(sui.indexrelid),indexrelname,'X'), '^CREATE UNIQUE','CREATE') as index_def,\n  case when not i.indisvalid then 1 else 0 end as is_invalid_int,\n  case when i.indisprimary then 1 else 0 end as is_pk_int\nFROM\n  pg_stat_user_indexes sui\n  JOIN\n  pg_index i USING (indexrelid)\nWHERE\n  NOT schemaname like E'pg\\\\_temp%'\n  AND i.indrelid not in (select relation from q_locked_rels)\n  AND i.indexrelid not in (select relation from q_locked_rels)\nORDER BY\n  schemaname, relname, indexrelname;\n	\N	t	f	2019-10-04 22:09:34.755459-07	f	f	{"prometheus_gauge_columns": ["index_size_b", "is_invalid_int", "is_pk_int"]}	
13	kpi	9.0	\nWITH q_stat_tables AS (\n  SELECT * FROM pg_stat_user_tables t\n  JOIN pg_class c ON c.oid = t.relid\n  WHERE NOT schemaname LIKE E'pg\\\\_temp%'\n  AND c.relpages > (1e7 / 8)    -- >10MB\n),\nq_stat_activity AS (\n  SELECT * FROM get_stat_activity()\n)\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  numbackends - 1 as numbackends,\n  (select count(*) from q_stat_activity where not current_query in ('<IDLE>', '<IDLE> in transaction')) AS active_backends,\n  (select count(*) from q_stat_activity where waiting) AS blocked_backends,\n  (select round(extract(epoch from now()) - extract(epoch from (select xact_start from q_stat_activity\n    where datid = d.datid and not current_query like 'autovacuum:%' order by xact_start limit 1))))::int AS kpi_oldest_tx_s,\n  xact_commit + xact_rollback AS tps,\n  xact_commit,\n  xact_rollback,\n  blks_read,\n  blks_hit,\n  (select sum(seq_scan) from q_stat_tables)::int8 AS seq_scans_on_tbls_gt_10mb,\n  tup_inserted,\n  tup_updated,\n  tup_deleted,\n  (select sum(calls) from pg_stat_user_functions where not schemaname like any(array[E'pg\\\\_%', 'information_schema']))::int8 AS sproc_calls,\n  extract(epoch from (now() - pg_postmaster_start_time()))::int8 as postmaster_uptime_s\nFROM\n  pg_stat_database d\nWHERE\n  datname = current_database();\n	\N	t	f	2019-10-04 22:09:34.756009-07	f	f	{"prometheus_gauge_columns": ["numbackends", "active_backends", "blocked_backends", "kpi_oldest_tx_s"]}	\nWITH q_stat_tables AS (\n  SELECT * FROM pg_stat_user_tables t\n  JOIN pg_class c ON c.oid = t.relid\n  WHERE NOT schemaname LIKE E'pg\\\\_temp%'\n  AND c.relpages > (1e7 / 8)    -- >10MB\n),\nq_stat_activity AS (\n  SELECT * FROM pg_stat_activity WHERE procpid != pg_backend_pid() AND datname = current_database()\n)\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  numbackends - 1 as numbackends,\n  (select count(*) from q_stat_activity where not current_query in ('<IDLE>', '<IDLE> in transaction')) AS active_backends,\n  (select count(*) from q_stat_activity where waiting) AS blocked_backends,\n  (select round(extract(epoch from now()) - extract(epoch from (select xact_start from q_stat_activity\n    where datid = d.datid and not current_query like 'autovacuum:%' order by xact_start limit 1))))::int AS kpi_oldest_tx_s,\n  xact_commit + xact_rollback AS tps,\n  xact_commit,\n  xact_rollback,\n  blks_read,\n  blks_hit,\n  (select sum(seq_scan) from q_stat_tables)::int8 AS seq_scans_on_tbls_gt_10mb,\n  tup_inserted,\n  tup_updated,\n  tup_deleted,\n  (select sum(calls) from pg_stat_user_functions where not schemaname like any(array[E'pg\\\\_%', 'information_schema']))::int8 AS sproc_calls,\n  extract(epoch from (now() - pg_postmaster_start_time()))::int8 as postmaster_uptime_s\nFROM\n  pg_stat_database d\nWHERE\n  datname = current_database();\n
14	kpi	9.2	\nWITH q_stat_tables AS (\n  SELECT * FROM pg_stat_user_tables t\n  JOIN pg_class c ON c.oid = t.relid\n  WHERE NOT schemaname LIKE E'pg\\\\_temp%'\n  AND c.relpages > (1e7 / 8)    -- >10MB\n),\nq_stat_activity AS (\n  SELECT * FROM get_stat_activity()\n)\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  case\n      when pg_is_in_recovery() = false then\n          pg_xlog_location_diff(pg_current_xlog_location(), '0/0')::int8\n      else\n          pg_xlog_location_diff(pg_last_xlog_replay_location(), '0/0')::int8\n      end as wal_location_b,\n  numbackends - 1 as numbackends,\n  (select count(1) from q_stat_activity where state = 'active') AS active_backends,\n  (select count(1) from q_stat_activity where waiting) AS blocked_backends,\n  (select round(extract(epoch from now()) - extract(epoch from (select xact_start from q_stat_activity\n    where datid = d.datid and not query like 'autovacuum:%' order by xact_start limit 1))))::int AS kpi_oldest_tx_s,\n  xact_commit + xact_rollback AS tps,\n  xact_commit,\n  xact_rollback,\n  blks_read,\n  blks_hit,\n  temp_bytes,\n  (select sum(seq_scan) from q_stat_tables)::int8 AS seq_scans_on_tbls_gt_10mb,\n  tup_inserted,\n  tup_updated,\n  tup_deleted,\n  (select sum(calls) from pg_stat_user_functions where not schemaname like any(array[E'pg\\\\_%', 'information_schema']))::int8 AS sproc_calls,\n  blk_read_time,\n  blk_write_time,\n  deadlocks,\n  case when pg_is_in_recovery() then 1 else 0 end as in_recovery_int,\n  extract(epoch from (now() - pg_postmaster_start_time()))::int8 as postmaster_uptime_s\nFROM\n  pg_stat_database d\nWHERE\n  datname = current_database();\n	\N	t	f	2019-10-04 22:09:34.756695-07	f	f	{"prometheus_gauge_columns": ["numbackends", "active_backends", "blocked_backends", "kpi_oldest_tx_s"]}	\nWITH q_stat_tables AS (\n    SELECT * FROM pg_stat_user_tables t\n                      JOIN pg_class c ON c.oid = t.relid\n    WHERE NOT schemaname LIKE E'pg\\\\_temp%'\n      AND c.relpages > (1e7 / 8)    -- >10MB\n),\n     q_stat_activity AS (\n         SELECT * FROM pg_stat_activity\n         WHERE datname = current_database() AND pid != pg_backend_pid()\n     )\nSELECT\n    (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  case\n      when pg_is_in_recovery() = false then\n          pg_xlog_location_diff(pg_current_xlog_location(), '0/0')::int8\n      else\n          pg_xlog_location_diff(pg_last_xlog_replay_location(), '0/0')::int8\n      end as wal_location_b,\n    numbackends - 1 as numbackends,\n    (select count(1) from q_stat_activity where state = 'active') AS active_backends,\n    (select count(1) from q_stat_activity where waiting) AS blocked_backends,\n    (select round(extract(epoch from now()) - extract(epoch from (select xact_start from q_stat_activity\n                                                                  where datid = d.datid and not query like 'autovacuum:%' order by xact_start limit 1))))::int AS kpi_oldest_tx_s,\n    xact_commit + xact_rollback AS tps,\n    xact_commit,\n    xact_rollback,\n    blks_read,\n    blks_hit,\n    temp_bytes,\n    (select sum(seq_scan) from q_stat_tables)::int8 AS seq_scans_on_tbls_gt_10mb,\n    tup_inserted,\n    tup_updated,\n    tup_deleted,\n    (select sum(calls) from pg_stat_user_functions where not schemaname like any(array[E'pg\\\\_%', 'information_schema']))::int8 AS sproc_calls,\n    blk_read_time,\n    blk_write_time,\n    deadlocks,\n    case when pg_is_in_recovery() then 1 else 0 end as in_recovery_int,\n    extract(epoch from (now() - pg_postmaster_start_time()))::int8 as postmaster_uptime_s\nFROM\n    pg_stat_database d\nWHERE\n    datname = current_database();\n
15	kpi	9.6	\nWITH q_stat_tables AS (\n  SELECT * FROM pg_stat_user_tables t\n  JOIN pg_class c ON c.oid = t.relid\n  WHERE NOT schemaname LIKE E'pg\\\\_temp%'\n  AND c.relpages > (1e7 / 8)    -- >10MB\n),\nq_stat_activity AS (\n  SELECT * FROM get_stat_activity()\n)\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  case\n    when pg_is_in_recovery() = false then\n      pg_xlog_location_diff(pg_current_xlog_location(), '0/0')::int8\n    else\n      pg_xlog_location_diff(pg_last_xlog_replay_location(), '0/0')::int8\n    end as wal_location_b,\n  numbackends - 1 as numbackends,\n  (select count(1) from q_stat_activity where state = 'active') AS active_backends,\n  (select count(1) from q_stat_activity where wait_event_type is not null) AS blocked_backends,\n  (select round(extract(epoch from now()) - extract(epoch from (select xact_start from q_stat_activity\n    where datid = d.datid and not query like 'autovacuum:%' order by xact_start limit 1))))::int AS kpi_oldest_tx_s,\n  xact_commit + xact_rollback AS tps,\n  xact_commit,\n  xact_rollback,\n  blks_read,\n  blks_hit,\n  temp_bytes,\n  (select sum(seq_scan) from q_stat_tables)::int8 AS seq_scans_on_tbls_gt_10mb,\n  tup_inserted,\n  tup_updated,\n  tup_deleted,\n  (select sum(calls) from pg_stat_user_functions where not schemaname like any(array[E'pg\\\\_%', 'information_schema']))::int8 AS sproc_calls,\n  blk_read_time,\n  blk_write_time,\n  deadlocks,\n  case when pg_is_in_recovery() then 1 else 0 end as in_recovery_int,\n  extract(epoch from (now() - pg_postmaster_start_time()))::int8 as postmaster_uptime_s\nFROM\n  pg_stat_database d\nWHERE\n  datname = current_database();\n	\N	t	f	2019-10-04 22:09:34.757719-07	f	f	{"prometheus_gauge_columns": ["numbackends", "active_backends", "blocked_backends", "kpi_oldest_tx_s"]}	\nWITH q_stat_tables AS (\n  SELECT * FROM pg_stat_user_tables t\n  JOIN pg_class c ON c.oid = t.relid\n  WHERE NOT schemaname LIKE E'pg\\\\_temp%'\n  AND c.relpages > (1e7 / 8)    -- >10MB\n),\nq_stat_activity AS (\n    SELECT * FROM pg_stat_activity\n    WHERE datname = current_database() AND pid != pg_backend_pid()\n)\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  case\n    when pg_is_in_recovery() = false then\n      pg_xlog_location_diff(pg_current_xlog_location(), '0/0')::int8\n    else\n      pg_xlog_location_diff(pg_last_xlog_replay_location(), '0/0')::int8\n    end as xlog_location_b,\n  numbackends - 1 as numbackends,\n  (select count(*) from q_stat_activity where state in ('active', 'idle in transaction')) AS active_backends,\n  (select count(*) from q_stat_activity where wait_event_type in ('LWLockNamed', 'Lock', 'BufferPin')) AS blocked_backends,\n  (select round(extract(epoch from now()) - extract(epoch from (select xact_start from q_stat_activity\n    where datid = d.datid and not query like 'autovacuum:%' order by xact_start limit 1))))::int AS kpi_oldest_tx_s,\n  xact_commit + xact_rollback AS tps,\n  xact_commit,\n  xact_rollback,\n  blks_read,\n  blks_hit,\n  temp_bytes,\n  (select sum(seq_scan) from q_stat_tables)::int8 AS seq_scans_on_tbls_gt_10mb,\n  tup_inserted,\n  tup_updated,\n  tup_deleted,\n  (select sum(calls) from pg_stat_user_functions where not schemaname like any(array[E'pg\\\\_%', 'information_schema']))::int8 AS sproc_calls,\n  blk_read_time,\n  blk_write_time,\n  deadlocks,\n  case when pg_is_in_recovery() then 1 else 0 end as in_recovery_int,\n  extract(epoch from (now() - pg_postmaster_start_time()))::int8 as postmaster_uptime_s\nFROM\n  pg_stat_database d\nWHERE\n  datname = current_database();\n
16	kpi	10	\nWITH q_stat_tables AS (\n  SELECT * FROM pg_stat_user_tables t\n  JOIN pg_class c ON c.oid = t.relid\n  WHERE NOT schemaname LIKE E'pg\\\\_temp%'\n  AND c.relpages > (1e7 / 8)    -- >10MB\n),\nq_stat_activity AS (\n  SELECT * FROM get_stat_activity()\n)\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  case\n      when pg_is_in_recovery() = false then\n          pg_wal_lsn_diff(pg_current_wal_lsn(), '0/0')::int8\n      else\n          pg_wal_lsn_diff(pg_last_wal_replay_lsn(), '0/0')::int8\n      end as wal_location_b,\n  numbackends - 1 as numbackends,\n  (select count(1) from q_stat_activity where state = 'active') AS active_backends,\n  (select count(1) from q_stat_activity where wait_event_type is not null) AS blocked_backends,\n  (select round(extract(epoch from now()) - extract(epoch from (select xact_start from q_stat_activity\n    where datid = d.datid and not query like 'autovacuum:%' order by xact_start limit 1))))::int AS kpi_oldest_tx_s,\n  xact_commit + xact_rollback AS tps,\n  xact_commit,\n  xact_rollback,\n  blks_read,\n  blks_hit,\n  temp_bytes,\n  (select sum(seq_scan) from q_stat_tables)::int8 AS seq_scans_on_tbls_gt_10mb,\n  tup_inserted,\n  tup_updated,\n  tup_deleted,\n  (select sum(calls) from pg_stat_user_functions where not schemaname like any(array[E'pg\\\\_%', 'information_schema']))::int8 AS sproc_calls,\n  blk_read_time,\n  blk_write_time,\n  deadlocks,\n  case when pg_is_in_recovery() then 1 else 0 end as in_recovery_int,\n  extract(epoch from (now() - pg_postmaster_start_time()))::int8 as postmaster_uptime_s\nFROM\n  pg_stat_database d\nWHERE\n  datname = current_database();\n	\N	t	f	2019-10-04 22:09:34.758441-07	f	f	{"prometheus_gauge_columns": ["numbackends", "active_backends", "blocked_backends", "kpi_oldest_tx_s"]}	\nWITH q_stat_tables AS (\n  SELECT * FROM pg_stat_user_tables t\n  JOIN pg_class c ON c.oid = t.relid\n  WHERE NOT schemaname LIKE E'pg\\\\_temp%'\n  AND c.relpages > (1e7 / 8)    -- >10MB\n),\nq_stat_activity AS (\n    SELECT * FROM pg_stat_activity\n    WHERE datname = current_database() AND pid != pg_backend_pid()\n)\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  case\n      when pg_is_in_recovery() = false then\n          pg_wal_lsn_diff(pg_current_wal_lsn(), '0/0')::int8\n      else\n          pg_wal_lsn_diff(pg_last_wal_replay_lsn(), '0/0')::int8\n      end as wal_location_b,\n  numbackends - 1 as numbackends,\n  (select count(*) from q_stat_activity where state in ('active', 'idle in transaction')) AS active_backends,\n  (select count(*) from q_stat_activity where wait_event_type in ('LWLock', 'Lock', 'BufferPin')) AS blocked_backends,\n  (select round(extract(epoch from now()) - extract(epoch from (select xact_start from q_stat_activity\n    where datid = d.datid and not query like 'autovacuum:%' order by xact_start limit 1))))::int AS kpi_oldest_tx_s,\n  xact_commit + xact_rollback AS tps,\n  xact_commit,\n  xact_rollback,\n  blks_read,\n  blks_hit,\n  temp_bytes,\n  (select sum(seq_scan) from q_stat_tables)::int8 AS seq_scans_on_tbls_gt_10mb,\n  tup_inserted,\n  tup_updated,\n  tup_deleted,\n  (select sum(calls) from pg_stat_user_functions where not schemaname like any(array[E'pg\\\\_%', 'information_schema']))::int8 AS sproc_calls,\n  blk_read_time,\n  blk_write_time,\n  deadlocks,\n  case when pg_is_in_recovery() then 1 else 0 end as in_recovery_int,\n  extract(epoch from (now() - pg_postmaster_start_time()))::int8 as postmaster_uptime_s\nFROM\n  pg_stat_database d\nWHERE\n  datname = current_database();\n
17	replication	9.2	\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  application_name as tag_application_name,\n  concat(coalesce(client_addr::text, client_hostname), '_', client_port::text) as tag_client_info,\n  coalesce(pg_xlog_location_diff(pg_current_xlog_location(), write_location)::int8, 0) as write_lag_b,\n  coalesce(pg_xlog_location_diff(pg_current_xlog_location(), flush_location)::int8, 0) as flush_lag_b,\n  coalesce(pg_xlog_location_diff(pg_current_xlog_location(), replay_location)::int8, 0) as replay_lag_b,\n  state,\n  sync_state,\n  case when sync_state in ('sync', 'quorum') then 1 else 0 end as is_sync_int\nfrom\n  get_stat_replication();\n	\N	t	f	2019-10-04 22:09:34.75913-07	t	f	{"prometheus_all_gauge_columns": true}	\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  application_name as tag_application_name,\n  concat(coalesce(client_addr::text, client_hostname), '_', client_port::text) as tag_client_info,\n  coalesce(pg_xlog_location_diff(pg_current_xlog_location(), write_location)::int8, 0) as write_lag_b,\n  coalesce(pg_xlog_location_diff(pg_current_xlog_location(), flush_location)::int8, 0) as flush_lag_b,\n  coalesce(pg_xlog_location_diff(pg_current_xlog_location(), replay_location)::int8, 0) as replay_lag_b,\n  state,\n  sync_state,\n  case when sync_state in ('sync', 'quorum') then 1 else 0 end as is_sync_int\nfrom\n  pg_stat_replication\n
18	replication	10	\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  application_name as tag_application_name,\n  concat(coalesce(client_addr::text, client_hostname), '_', client_port::text) as tag_client_info,\n  coalesce(pg_wal_lsn_diff(pg_current_wal_lsn(), write_lsn)::int8, 0) as write_lag_b,\n  coalesce(pg_wal_lsn_diff(pg_current_wal_lsn(), flush_lsn)::int8, 0) as flush_lag_b,\n  coalesce(pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn)::int8, 0) as replay_lag_b,\n  state,\n  sync_state,\n  case when sync_state in ('sync', 'quorum') then 1 else 0 end as is_sync_int\nfrom\n  /* NB! when the query fails, grant "pg_monitor" system role (exposing all stats) to the monitoring user\n     or create specifically the "get_stat_replication" helper and use that instead of pg_stat_replication\n  */\n  pg_stat_replication;\n	\N	t	f	2019-10-04 22:09:34.759668-07	t	f	{"prometheus_all_gauge_columns": true}	
19	sproc_stats	9.0	\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  schemaname::text AS tag_schema,\n  funcname::text  AS tag_function_name,\n  quote_ident(schemaname)||'.'||quote_ident(funcname) as tag_function_full_name,\n  p.oid::text as tag_oid, -- for overloaded funcs\n  calls as sp_calls,\n  self_time,\n  total_time\nFROM\n  pg_stat_user_functions f\n  JOIN\n  pg_proc p ON p.oid = f.funcid;\n	\N	t	f	2019-10-04 22:09:34.760124-07	f	f	\N	
20	table_io_stats	9.0	\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  schemaname::text as tag_schema,\n  relname::text as tag_table_name,\n  quote_ident(schemaname)||'.'||quote_ident(relname) as tag_table_full_name,\n  heap_blks_read,\n  heap_blks_hit,\n  idx_blks_read,\n  idx_blks_hit,\n  toast_blks_read,\n  toast_blks_hit,\n  tidx_blks_read,\n  tidx_blks_hit\nFROM\n  pg_statio_user_tables\nWHERE\n  NOT schemaname LIKE E'pg\\\\_temp%'\n  AND (heap_blks_read > 0 OR heap_blks_hit > 0 OR idx_blks_read > 0 OR idx_blks_hit > 0 OR tidx_blks_read > 0 OR tidx_blks_hit > 0);\n	\N	t	f	2019-10-04 22:09:34.760527-07	f	f	\N	
32	locks_mode	9.0	\nWITH q_locks AS (\n  select\n    *\n  from\n    pg_locks\n  where\n    pid != pg_backend_pid()\n    and database = (select oid from pg_database where datname = current_database())\n)\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  lockmodes AS tag_lockmode,\n  coalesce((select count(*) FROM q_locks WHERE mode = lockmodes), 0) AS count\nFROM\n  unnest('{AccessShareLock, ExclusiveLock, RowShareLock, RowExclusiveLock, ShareLock, ShareRowExclusiveLock,  AccessExclusiveLock, ShareUpdateExclusiveLock}'::text[]) lockmodes;\n	\N	t	f	2019-10-04 22:09:34.765961-07	f	f	{"prometheus_gauge_columns": ["count"]}	
21	table_stats	9.0	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  quote_ident(schemaname) as tag_schema,\n  quote_ident(ut.relname) as tag_table_name,\n  quote_ident(schemaname)||'.'||quote_ident(ut.relname) as tag_table_full_name,\n  pg_table_size(relid) as table_size_b,\n  abs(greatest(ceil(log((pg_table_size(relid)+1) / 10^6)), 0))::text as tag_table_size_cardinality_mb, -- i.e. 0=<1MB, 1=<10MB, 2=<100MB,..\n  pg_total_relation_size(relid) as total_relation_size_b,\n  case when reltoastrelid != 0 then pg_total_relation_size(reltoastrelid) else 0::int8 end as toast_size_b,\n  (extract(epoch from now() - greatest(last_vacuum, last_autovacuum)))::int8 as seconds_since_last_vacuum,\n  (extract(epoch from now() - greatest(last_analyze, last_autoanalyze)))::int8 as seconds_since_last_analyze,\n  case when 'autovacuum_enabled=off' = ANY(c.reloptions) then 1 else 0 end as no_autovacuum,\n  seq_scan,\n  seq_tup_read,\n  idx_scan,\n  idx_tup_fetch,\n  n_tup_ins,\n  n_tup_upd,\n  n_tup_del,\n  n_tup_hot_upd,\n  n_live_tup,\n  n_dead_tup,\n  age(relfrozenxid) as tx_freeze_age\nfrom\n  pg_stat_user_tables ut\n  join\n  pg_class c on c.oid = ut.relid\nwhere\n  -- leaving out fully locked tables as pg_relation_size also wants a lock and would wait\n  not exists (select 1 from pg_locks where relation = relid and mode = 'AccessExclusiveLock' and granted)\n  and c.relpersistence != 't'  order by toast_size_b desc nulls last; -- and temp tables\n	\N	t	f	2019-10-04 22:09:34.761012-07	f	f	{"prometheus_gauge_columns": ["table_size_b", "total_relation_size_b", "toast_size_b", "seconds_since_last_vacuum", "seconds_since_last_analyze", "n_live_tup", "n_dead_tup"]}	
22	table_stats	9.1	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  quote_ident(schemaname) as tag_schema,\n  quote_ident(ut.relname) as tag_table_name,\n  quote_ident(schemaname)||'.'||quote_ident(ut.relname) as tag_table_full_name,\n  pg_table_size(relid) as table_size_b,\n  abs(greatest(ceil(log((pg_table_size(relid)+1) / 10^6)), 0))::text as tag_table_size_cardinality_mb, -- i.e. 0=<1MB, 1=<10MB, 2=<100MB,..\n  pg_total_relation_size(relid) as total_relation_size_b,\n  pg_total_relation_size((select reltoastrelid from pg_class where oid = ut.relid)) as toast_size_b,\n  (extract(epoch from now() - greatest(last_vacuum, last_autovacuum)))::int8 as seconds_since_last_vacuum,\n  (extract(epoch from now() - greatest(last_analyze, last_autoanalyze)))::int8 as seconds_since_last_analyze,\n  case when 'autovacuum_enabled=off' = ANY(c.reloptions) then 1 else 0 end as no_autovacuum,\n  seq_scan,\n  seq_tup_read,\n  idx_scan,\n  idx_tup_fetch,\n  n_tup_ins,\n  n_tup_upd,\n  n_tup_del,\n  n_tup_hot_upd,\n  n_live_tup,\n  n_dead_tup,\n  vacuum_count,\n  autovacuum_count,\n  analyze_count,\n  autoanalyze_count,\n  age(relfrozenxid) as tx_freeze_age\nfrom\n  pg_stat_user_tables ut\n  join\n  pg_class c on c.oid = ut.relid\nwhere\n  -- leaving out fully locked tables as pg_relation_size also wants a lock and would wait\n  not exists (select 1 from pg_locks where relation = relid and mode = 'AccessExclusiveLock' and granted)\n  and c.relpersistence != 't'  order by toast_size_b desc nulls last; -- and temp tables\n	\N	t	f	2019-10-04 22:09:34.76155-07	f	f	{"prometheus_gauge_columns": ["table_size_b", "total_relation_size_b", "toast_size_b", "seconds_since_last_vacuum", "seconds_since_last_analyze", "n_live_tup", "n_dead_tup"]}	
23	wal	9.2	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  case\n    when pg_is_in_recovery() = false then\n      pg_xlog_location_diff(pg_current_xlog_location(), '0/0')::int8\n    else\n      pg_xlog_location_diff(pg_last_xlog_replay_location(), '0/0')::int8\n    end as xlog_location_b,\n  case when pg_is_in_recovery() then 1 else 0 end as in_recovery_int,\n  extract(epoch from (now() - pg_postmaster_start_time()))::int8 as postmaster_uptime_s;\n	\N	t	f	2019-10-04 22:09:34.762016-07	f	f	{"prometheus_gauge_columns": ["in_recovery_int", "postmaster_uptime_s"]}	
24	wal	10	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  case\n    when pg_is_in_recovery() = false then\n      pg_wal_lsn_diff(pg_current_wal_lsn(), '0/0')::int8\n    else\n      pg_wal_lsn_diff(pg_last_wal_replay_lsn(), '0/0')::int8\n    end as xlog_location_b,\n  case when pg_is_in_recovery() then 1 else 0 end as in_recovery_int,\n  extract(epoch from (now() - pg_postmaster_start_time()))::int8 as postmaster_uptime_s,\n  system_identifier::text as tag_sys_id\nfrom pg_control_system();\n	\N	t	f	2019-10-04 22:09:34.762482-07	f	f	{"prometheus_gauge_columns": ["in_recovery_int", "postmaster_uptime_s"]}	
25	stat_statements	9.2	\nwith q_data as (\n  select\n    (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n    queryid::text as tag_queryid,\n    max(ltrim(regexp_replace(query, E'[ \\\\t\\\\n\\\\r]+' , ' ', 'g')))::varchar(16000) as tag_query,\n    sum(s.calls)::int8 as calls,\n    sum(s.total_time)::double precision as total_time,\n    sum(shared_blks_hit)::int8 as shared_blks_hit,\n    sum(shared_blks_read)::int8 as shared_blks_read,\n    sum(shared_blks_written)::int8 as shared_blks_written,\n    sum(shared_blks_dirtied)::int8 as shared_blks_dirtied,\n    sum(temp_blks_read)::int8 as temp_blks_read,\n    sum(temp_blks_written)::int8 as temp_blks_written,\n    sum(blk_read_time)::double precision as blk_read_time,\n    sum(blk_write_time)::double precision as blk_write_time\n  from\n    get_stat_statements() s\n  where\n    calls > 5\n    and total_time > 0\n    and dbid = (select oid from pg_database where datname = current_database())\n    and not upper(s.query) like any (array['DEALLOCATE%', 'SET %', 'RESET %', 'BEGIN%', 'BEGIN;',\n      'COMMIT%', 'END%', 'ROLLBACK%', 'SHOW%'])\n  group by\n    queryid\n)\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    total_time > 0\n  order by\n    total_time desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  order by\n    calls desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    shared_blks_read > 0\n  order by\n    shared_blks_read desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    shared_blks_written > 0\n  order by\n    shared_blks_written desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    temp_blks_read > 0\n  order by\n    temp_blks_read desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    temp_blks_written > 0\n  order by\n    temp_blks_written desc\n  limit 100\n) a;\n	\N	t	f	2019-10-04 22:09:34.763223-07	f	f	\N	\nwith q_data as (\n  select\n    (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n    queryid::text as tag_queryid,\n    max(ltrim(regexp_replace(query, E'[ \\\\t\\\\n\\\\r]+' , ' ', 'g')))::varchar(16000) as tag_query,\n    sum(s.calls)::int8 as calls,\n    sum(s.total_time)::double precision as total_time,\n    sum(shared_blks_hit)::int8 as shared_blks_hit,\n    sum(shared_blks_read)::int8 as shared_blks_read,\n    sum(shared_blks_written)::int8 as shared_blks_written,\n    sum(shared_blks_dirtied)::int8 as shared_blks_dirtied,\n    sum(temp_blks_read)::int8 as temp_blks_read,\n    sum(temp_blks_written)::int8 as temp_blks_written,\n    sum(blk_read_time)::double precision as blk_read_time,\n    sum(blk_write_time)::double precision as blk_write_time\n  from\n    get_stat_statements() s\n  where\n    calls > 5\n    and total_time > 0\n    and dbid = (select oid from pg_database where datname = current_database())\n    and not upper(s.query) like any (array['DEALLOCATE%', 'SET %', 'RESET %', 'BEGIN%', 'BEGIN;',\n      'COMMIT%', 'END%', 'ROLLBACK%', 'SHOW%'])\n  group by\n    queryid\n)\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    total_time > 0\n  order by\n    total_time desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  order by\n    calls desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    shared_blks_read > 0\n  order by\n    shared_blks_read desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    shared_blks_written > 0\n  order by\n    shared_blks_written desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    temp_blks_read > 0\n  order by\n    temp_blks_read desc\n  limit 100\n) a\nunion\nselect * from (\n  select\n    *\n  from\n    q_data\n  where\n    temp_blks_written > 0\n  order by\n    temp_blks_written desc\n  limit 100\n) a;\n
26	stat_statements_calls	9.2	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  coalesce(sum(calls), 0)::int8 as calls,\n  coalesce(sum(total_time), 0)::float8 as total_time\nfrom\n  pg_stat_statements\nwhere\n  dbid = (select oid from pg_database where datname = current_database())\n;\n	\N	t	f	2019-10-04 22:09:34.763803-07	f	f	\N	
27	buffercache_by_db	9.2	\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  datname as tag_database,\n  count(*) * (current_setting('block_size')::int8) as size_b\nFROM\n  pg_buffercache AS b,\n  pg_database AS d\nWHERE\n  d.oid = b.reldatabase\nGROUP BY\n  datname;\n	\N	t	f	2019-10-04 22:09:34.76416-07	f	f	{"prometheus_gauge_columns": ["size_b"]}	
28	buffercache_by_type	9.2	\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  CASE\n    WHEN relkind = 'r' THEN 'Table'   -- TODO all relkinds covered?\n    WHEN relkind = 'i' THEN 'Index'\n    WHEN relkind = 't' THEN 'Toast'\n    WHEN relkind = 'm' THEN 'Materialized view'\n    ELSE 'Other'\n  END as tag_relkind,\n  count(*) * (current_setting('block_size')::int8) as size_b\nFROM\n  pg_buffercache AS b,\n  pg_class AS d\nWHERE\n  d.oid = b.relfilenode\nGROUP BY \n  relkind;\n	\N	t	f	2019-10-04 22:09:34.764493-07	f	f	{"prometheus_gauge_columns": ["size_b"]}	
29	stat_ssl	9.5	\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  ssl,\n  count(*)\nFROM\n  pg_stat_ssl AS s,\n  get_stat_activity() AS a\nWHERE\n  a.pid = s.pid\n  AND a.datname = current_database()\nGROUP BY\n  1, 2\n	\N	t	f	2019-10-04 22:09:34.764848-07	f	f	\N	\nSELECT\n(extract(epoch from now()) * 1e9)::int8 as epoch_ns,\nssl,\ncount(*)\n    FROM\n  pg_stat_ssl AS s,\npg_stat_activity AS a\nWHERE\n  a.pid = s.pid\n  AND a.datname = current_database()\nGROUP BY\n  1, 2;\n
33	blocking_locks	9.2	\nSELECT\n    (extract(epoch from now()) * 1e9)::int8 AS epoch_ns,\n    waiting.locktype           AS tag_waiting_locktype,\n    waiting_stm.usename        AS tag_waiting_user,\n    coalesce(waiting.mode, 'null'::text) AS tag_waiting_mode,\n    coalesce(waiting.relation::regclass::text, 'null') AS tag_waiting_table,\n    waiting_stm.query          AS waiting_query,\n    waiting.pid                AS waiting_pid,\n    other.locktype             AS other_locktype,\n    other.relation::regclass   AS other_table,\n    other_stm.query            AS other_query,\n    other.mode                 AS other_mode,\n    other.pid                  AS other_pid,\n    other_stm.usename          AS other_user\nFROM\n    pg_catalog.pg_locks AS waiting\nJOIN\n    get_stat_activity() AS waiting_stm\n    ON (\n        waiting_stm.pid = waiting.pid\n    )\nJOIN\n    pg_catalog.pg_locks AS other\n    ON (\n        (\n            waiting."database" = other."database"\n        AND waiting.relation  = other.relation\n        )\n        OR waiting.transactionid = other.transactionid\n    )\nJOIN\n    get_stat_activity() AS other_stm\n    ON (\n        other_stm.pid = other.pid\n    )\nWHERE\n    NOT waiting.GRANTED\nAND\n    waiting.pid <> other.pid\nAND\n    other.GRANTED\nAND\n    waiting_stm.datname = current_database();\n	\N	t	f	2019-10-04 22:09:34.766364-07	f	f	\N	
34	table_bloat_approx_stattuple	9.5	\n/* NB! accessing pgstattuple_approx directly requires superuser or pg_stat_scan_tables/pg_monitor builtin roles */\nselect\n  (extract(epoch from now()) * 1e9)::int8 AS epoch_ns,\n  quote_ident(n.nspname)||'.'||quote_ident(c.relname) as tag_full_table_name,\n  approx_free_percent,\n  approx_free_space as approx_free_space_b,\n  approx_tuple_count,\n  dead_tuple_percent,\n  dead_tuple_len as dead_tuple_len_b\nfrom\n  pg_class c\n  join lateral pgstattuple_approx(c.oid) st on (c.oid not in (select relation from pg_locks where mode = 'AccessExclusiveLock'))  -- skip locked tables,\n  join pg_namespace n on n.oid = c.relnamespace\nwhere\n  relkind in ('r', 'm')\n  and c.relpages >= 128 -- tables > 1mb\n  and not n.nspname like any (array[E'pg\\\\_%', 'information_schema']);\n	\N	t	f	2019-10-04 22:09:34.766753-07	t	f	{"prometheus_all_gauge_columns": true}	
35	get_table_bloat_approx	9.5	\nBEGIN;\n\nCREATE EXTENSION IF NOT EXISTS pgstattuple;\n\nCREATE OR REPLACE FUNCTION get_table_bloat_approx(\n  OUT approx_free_percent double precision, OUT approx_free_space double precision,\n  OUT dead_tuple_percent double precision, OUT dead_tuple_len double precision\n) AS\n$$\n    select\n      avg(approx_free_percent)::double precision as approx_free_percent,\n      sum(approx_free_space)::double precision as approx_free_space,\n      avg(dead_tuple_percent)::double precision as dead_tuple_percent,\n      sum(dead_tuple_len)::double precision as dead_tuple_len\n    from\n      pg_class c\n      join\n      pg_namespace n on n.oid = c.relnamespace\n      join lateral pgstattuple_approx(c.oid) on (c.oid not in (select relation from pg_locks where mode = 'AccessExclusiveLock'))  -- skip locked tables\n    where\n      relkind in ('r', 'm')\n      and c.relpages >= 128 -- tables >1mb\n      and not n.nspname like any (array[E'pg\\\\_%', 'information_schema'])\n$$ LANGUAGE sql SECURITY DEFINER;\n\nGRANT EXECUTE ON FUNCTION get_table_bloat_approx() TO pgwatch2;\nCOMMENT ON FUNCTION get_table_bloat_approx() is 'created for pgwatch2';\n\nCOMMIT;\n	for internal usage - when connecting user is marked as superuser then the daemon will automatically try to create the needed helpers on the monitored db	t	t	2019-10-04 22:09:34.76724-07	f	f	\N	
36	get_table_bloat_approx_sql	9.0	\n-- small modifications to SQL from https://github.com/ioguix/pgsql-bloat-estimation\n-- NB! monitoring user needs SELECT grant on all tables or a SECURITY DEFINER wrapper around that SQL\n\nCREATE OR REPLACE FUNCTION get_table_bloat_approx_sql(\n      OUT full_table_name text,\n      OUT approx_bloat_percent double precision,\n      OUT approx_bloat_bytes double precision,\n      OUT fillfactor integer\n    ) RETURNS SETOF RECORD\nLANGUAGE sql\nSECURITY DEFINER\nAS $$\n\nSELECT\n  quote_ident(schemaname)||'.'||quote_ident(tblname) as full_table_name,\n  bloat_ratio,\n  bloat_size,\n  fillfactor\nFROM (\n\n/* WARNING: executed with a non-superuser role, the query inspect only tables you are granted to read.\n* This query is compatible with PostgreSQL 9.0 and more\n*/\n         SELECT current_database(),\n                schemaname,\n                tblname,\n                bs * tblpages                  AS real_size,\n                (tblpages - est_tblpages) * bs AS extra_size,\n                CASE\n                    WHEN tblpages - est_tblpages > 0\n                        THEN 100 * (tblpages - est_tblpages) / tblpages::float\n                    ELSE 0\n                    END                        AS extra_ratio,\n                fillfactor,\n                CASE\n                    WHEN tblpages - est_tblpages_ff > 0\n                        THEN (tblpages - est_tblpages_ff) * bs\n                    ELSE 0\n                    END                        AS bloat_size,\n                CASE\n                    WHEN tblpages - est_tblpages_ff > 0\n                        THEN 100 * (tblpages - est_tblpages_ff) / tblpages::float\n                    ELSE 0\n                    END                        AS bloat_ratio,\n                is_na\n                -- , (pst).free_percent + (pst).dead_tuple_percent AS real_frag\n         FROM (\n                  SELECT ceil(reltuples / ((bs - page_hdr) / tpl_size)) + ceil(toasttuples / 4)                      AS est_tblpages,\n                         ceil(reltuples / ((bs - page_hdr) * fillfactor / (tpl_size * 100))) +\n                         ceil(toasttuples / 4)                                                                       AS est_tblpages_ff,\n                         tblpages,\n                         fillfactor,\n                         bs,\n                         tblid,\n                         schemaname,\n                         tblname,\n                         heappages,\n                         toastpages,\n                         is_na\n                         -- , stattuple.pgstattuple(tblid) AS pst\n                  FROM (\n                           SELECT (4 + tpl_hdr_size + tpl_data_size + (2 * ma)\n                               - CASE WHEN tpl_hdr_size % ma = 0 THEN ma ELSE tpl_hdr_size % ma END\n                               - CASE\n                                     WHEN ceil(tpl_data_size)::int % ma = 0 THEN ma\n                                     ELSE ceil(tpl_data_size)::int % ma END\n                                      )                    AS tpl_size,\n                                  bs - page_hdr            AS size_per_block,\n                                  (heappages + toastpages) AS tblpages,\n                                  heappages,\n                                  toastpages,\n                                  reltuples,\n                                  toasttuples,\n                                  bs,\n                                  page_hdr,\n                                  tblid,\n                                  schemaname,\n                                  tblname,\n                                  fillfactor,\n                                  is_na\n                           FROM (\n                                    SELECT tbl.oid                                                           AS tblid,\n                                           ns.nspname                                                        AS schemaname,\n                                           tbl.relname                                                       AS tblname,\n                                           tbl.reltuples,\n                                           tbl.relpages                                                      AS heappages,\n                                           coalesce(toast.relpages, 0)                                       AS toastpages,\n                                           coalesce(toast.reltuples, 0)                                      AS toasttuples,\n                                           coalesce(substring(\n                                                            array_to_string(tbl.reloptions, ' ')\n                                                            FROM 'fillfactor=([0-9]+)')::smallint,\n                                                    100)                                                     AS fillfactor,\n                                           current_setting('block_size')::numeric                            AS bs,\n                                           CASE\n                                               WHEN version() ~ 'mingw32' OR version() ~ '64-bit|x86_64|ppc64|ia64|amd64'\n                                                   THEN 8\n                                               ELSE 4 END                                                    AS ma,\n                                           24                                                                AS page_hdr,\n                                           23 + CASE\n                                                    WHEN MAX(coalesce(null_frac, 0)) > 0 THEN (7 + count(*)) / 8\n                                                    ELSE 0::int END\n                                               +\n                                           CASE WHEN tbl.relhasoids THEN 4 ELSE 0 END                        AS tpl_hdr_size,\n                                           sum((1 - coalesce(s.null_frac, 0)) * coalesce(s.avg_width, 1024)) AS tpl_data_size,\n                                           bool_or(att.atttypid = 'pg_catalog.name'::regtype)\n                                               OR count(att.attname) <> count(s.attname)                     AS is_na\n                                    FROM pg_attribute AS att\n                                             JOIN pg_class AS tbl ON att.attrelid = tbl.oid\n                                             JOIN pg_namespace AS ns ON ns.oid = tbl.relnamespace\n                                             LEFT JOIN pg_stats AS s ON s.schemaname = ns.nspname\n                                        AND s.tablename = tbl.relname AND s.inherited = false AND\n                                                                        s.attname = att.attname\n                                             LEFT JOIN pg_class AS toast ON tbl.reltoastrelid = toast.oid\n                                    WHERE att.attnum > 0\n                                      AND NOT att.attisdropped\n                                      AND tbl.relkind IN ('r', 'm')\n                                      AND ns.nspname != 'information_schema'\n                                    GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, tbl.relhasoids\n                                    ORDER BY 2, 3\n                                ) AS s\n                       ) AS s2\n              ) AS s3\n         WHERE NOT is_na\n ) s4\n$$;\n\nGRANT EXECUTE ON FUNCTION get_table_bloat_approx_sql() TO pgwatch2;\nCOMMENT ON FUNCTION get_table_bloat_approx_sql() is 'created for pgwatch2';\n\n	\N	t	t	2019-10-04 22:09:34.768022-07	f	f	\N	
37	get_table_bloat_approx_sql	12	\n-- small modifications to SQL from https://github.com/ioguix/pgsql-bloat-estimation\n-- NB! monitoring user needs SELECT grant on all tables or a SECURITY DEFINER wrapper around that SQL\n\nCREATE OR REPLACE FUNCTION get_table_bloat_approx_sql(\n      OUT full_table_name text,\n      OUT approx_bloat_percent double precision,\n      OUT approx_bloat_bytes double precision,\n      OUT fillfactor integer\n    ) RETURNS SETOF RECORD\nLANGUAGE sql\nSECURITY DEFINER\nAS $$\n\nSELECT\n  quote_ident(schemaname)||'.'||quote_ident(tblname) as full_table_name,\n  bloat_ratio,\n  bloat_size,\n  fillfactor\nFROM (\n\n/* WARNING: executed with a non-superuser role, the query inspect only tables you are granted to read.\n* This query is compatible with PostgreSQL 9.0 and more\n*/\n         SELECT current_database(),\n                schemaname,\n                tblname,\n                bs * tblpages                  AS real_size,\n                (tblpages - est_tblpages) * bs AS extra_size,\n                CASE\n                    WHEN tblpages - est_tblpages > 0\n                        THEN 100 * (tblpages - est_tblpages) / tblpages::float\n                    ELSE 0\n                    END                        AS extra_ratio,\n                fillfactor,\n                CASE\n                    WHEN tblpages - est_tblpages_ff > 0\n                        THEN (tblpages - est_tblpages_ff) * bs\n                    ELSE 0\n                    END                        AS bloat_size,\n                CASE\n                    WHEN tblpages - est_tblpages_ff > 0\n                        THEN 100 * (tblpages - est_tblpages_ff) / tblpages::float\n                    ELSE 0\n                    END                        AS bloat_ratio,\n                is_na\n                -- , (pst).free_percent + (pst).dead_tuple_percent AS real_frag\n         FROM (\n                  SELECT ceil(reltuples / ((bs - page_hdr) / tpl_size)) + ceil(toasttuples / 4)                      AS est_tblpages,\n                         ceil(reltuples / ((bs - page_hdr) * fillfactor / (tpl_size * 100))) +\n                         ceil(toasttuples / 4)                                                                       AS est_tblpages_ff,\n                         tblpages,\n                         fillfactor,\n                         bs,\n                         tblid,\n                         schemaname,\n                         tblname,\n                         heappages,\n                         toastpages,\n                         is_na\n                         -- , stattuple.pgstattuple(tblid) AS pst\n                  FROM (\n                           SELECT (4 + tpl_hdr_size + tpl_data_size + (2 * ma)\n                               - CASE WHEN tpl_hdr_size % ma = 0 THEN ma ELSE tpl_hdr_size % ma END\n                               - CASE\n                                     WHEN ceil(tpl_data_size)::int % ma = 0 THEN ma\n                                     ELSE ceil(tpl_data_size)::int % ma END\n                                      )                    AS tpl_size,\n                                  bs - page_hdr            AS size_per_block,\n                                  (heappages + toastpages) AS tblpages,\n                                  heappages,\n                                  toastpages,\n                                  reltuples,\n                                  toasttuples,\n                                  bs,\n                                  page_hdr,\n                                  tblid,\n                                  schemaname,\n                                  tblname,\n                                  fillfactor,\n                                  is_na\n                           FROM (\n                                    SELECT tbl.oid                                                           AS tblid,\n                                           ns.nspname                                                        AS schemaname,\n                                           tbl.relname                                                       AS tblname,\n                                           tbl.reltuples,\n                                           tbl.relpages                                                      AS heappages,\n                                           coalesce(toast.relpages, 0)                                       AS toastpages,\n                                           coalesce(toast.reltuples, 0)                                      AS toasttuples,\n                                           coalesce(substring(\n                                                            array_to_string(tbl.reloptions, ' ')\n                                                            FROM 'fillfactor=([0-9]+)')::smallint,\n                                                    100)                                                     AS fillfactor,\n                                           current_setting('block_size')::numeric                            AS bs,\n                                           CASE\n                                               WHEN version() ~ 'mingw32' OR version() ~ '64-bit|x86_64|ppc64|ia64|amd64'\n                                                   THEN 8\n                                               ELSE 4 END                                                    AS ma,\n                                           24                                                                AS page_hdr,\n                                           23 + CASE\n                                                    WHEN MAX(coalesce(null_frac, 0)) > 0 THEN (7 + count(*)) / 8\n                                                    ELSE 0::int END\n                                               +\n                                           0                                                                 AS tpl_hdr_size,\n                                           sum((1 - coalesce(s.null_frac, 0)) * coalesce(s.avg_width, 1024)) AS tpl_data_size,\n                                           bool_or(att.atttypid = 'pg_catalog.name'::regtype)\n                                               OR count(att.attname) <> count(s.attname)                     AS is_na\n                                    FROM pg_attribute AS att\n                                             JOIN pg_class AS tbl ON att.attrelid = tbl.oid\n                                             JOIN pg_namespace AS ns ON ns.oid = tbl.relnamespace\n                                             LEFT JOIN pg_stats AS s ON s.schemaname = ns.nspname\n                                        AND s.tablename = tbl.relname AND s.inherited = false AND\n                                                                        s.attname = att.attname\n                                             LEFT JOIN pg_class AS toast ON tbl.reltoastrelid = toast.oid\n                                    WHERE att.attnum > 0\n                                      AND NOT att.attisdropped\n                                      AND tbl.relkind IN ('r', 'm')\n                                      AND ns.nspname != 'information_schema'\n                                    GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n                                    ORDER BY 2, 3\n                                ) AS s\n                       ) AS s2\n              ) AS s3\n         WHERE NOT is_na\n ) s4\n$$;\n\nGRANT EXECUTE ON FUNCTION get_table_bloat_approx_sql() TO pgwatch2;\nCOMMENT ON FUNCTION get_table_bloat_approx_sql() is 'created for pgwatch2';\n\n	\N	t	t	2019-10-04 22:09:34.769396-07	f	f	\N	
38	table_bloat_approx_summary	9.5	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  approx_free_percent,\n  approx_free_space as approx_free_space_b,\n  dead_tuple_percent,\n  dead_tuple_len as dead_tuple_len_b\nfrom\n  get_table_bloat_approx()\nwhere\n  approx_free_space > 0\n	\N	t	f	2019-10-04 22:09:34.770328-07	t	f	{"prometheus_all_gauge_columns": true}	\nwith table_bloat_approx as (\n    select\n        avg(approx_free_percent)::double precision as approx_free_percent,\n        sum(approx_free_space)::double precision as approx_free_space,\n        avg(dead_tuple_percent)::double precision as dead_tuple_percent,\n        sum(dead_tuple_len)::double precision as dead_tuple_len\n    from\n        pg_class c\n            join\n        pg_namespace n on n.oid = c.relnamespace\n            join lateral pgstattuple_approx(c.oid) on (c.oid not in (select relation from pg_locks where mode = 'AccessExclusiveLock'))  -- skip locked tables\n    where\n        relkind in ('r', 'm')\n        and c.relpages >= 128 -- tables >1mb\n        and not n.nspname like any (array[E'pg\\\\_%', 'information_schema'])\n)\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  approx_free_percent,\n  approx_free_space as approx_free_space_b,\n  dead_tuple_percent,\n  dead_tuple_len as dead_tuple_len_b\nfrom\n  table_bloat_approx\nwhere\n  approx_free_space > 0;\n
39	table_bloat_approx_summary	10	\n/* NB! accessing pgstattuple_approx directly requires superuser or pg_stat_scan_tables/pg_monitor builtin roles or\n   execute grant on pgstattuple_approx(regclass)\n*/\nwith table_bloat_approx as (\n    select\n        avg(approx_free_percent)::double precision as approx_free_percent,\n        sum(approx_free_space)::double precision as approx_free_space,\n        avg(dead_tuple_percent)::double precision as dead_tuple_percent,\n        sum(dead_tuple_len)::double precision as dead_tuple_len\n    from\n        pg_class c\n            join\n        pg_namespace n on n.oid = c.relnamespace\n            join lateral pgstattuple_approx(c.oid) on (c.oid not in (select relation from pg_locks where mode = 'AccessExclusiveLock'))  -- skip locked tables\n    where\n        relkind in ('r', 'm')\n        and c.relpages >= 128 -- tables >1mb\n        and not n.nspname != 'information_schema'\n)\nselect\n    (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n    approx_free_percent,\n    approx_free_space as approx_free_space_b,\n    dead_tuple_percent,\n    dead_tuple_len as dead_tuple_len_b\nfrom\n    table_bloat_approx\nwhere\n     approx_free_space > 0;\n\n	\N	t	f	2019-10-04 22:09:34.770789-07	t	f	{"prometheus_all_gauge_columns": true}	
40	table_bloat_approx_summary_sql	9.0	\nWITH q_bloat AS (\n    select * from get_table_bloat_approx_sql()\n)\nSELECT\n    (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n    (select sum(approx_bloat_bytes) from q_bloat) as approx_table_bloat_b,\n    ((select sum(approx_bloat_bytes) from q_bloat) * 100 / pg_database_size(current_database()))::int8 as approx_bloat_percentage\n;\n	\N	t	f	2019-10-04 22:09:34.771515-07	t	f	{"prometheus_all_gauge_columns": true}	\nWITH q_bloat AS (\n    SELECT\n                quote_ident(schemaname)||'.'||quote_ident(tblname) as full_table_name,\n                bloat_ratio as approx_bloat_percent,\n                bloat_size as approx_bloat_bytes,\n                fillfactor\n    FROM (\n\n/* WARNING: executed with a non-superuser role, the query inspect only tables you are granted to read.\n* This query is compatible with PostgreSQL 9.0 and more\n*/\n             SELECT current_database(),\n                    schemaname,\n                    tblname,\n                    bs * tblpages                  AS real_size,\n                    (tblpages - est_tblpages) * bs AS extra_size,\n                    CASE\n                        WHEN tblpages - est_tblpages > 0\n                            THEN 100 * (tblpages - est_tblpages) / tblpages::float\n                        ELSE 0\n                        END                        AS extra_ratio,\n                    fillfactor,\n                    CASE\n                        WHEN tblpages - est_tblpages_ff > 0\n                            THEN (tblpages - est_tblpages_ff) * bs\n                        ELSE 0\n                        END                        AS bloat_size,\n                    CASE\n                        WHEN tblpages - est_tblpages_ff > 0\n                            THEN 100 * (tblpages - est_tblpages_ff) / tblpages::float\n                        ELSE 0\n                        END                        AS bloat_ratio,\n                    is_na\n                    -- , (pst).free_percent + (pst).dead_tuple_percent AS real_frag\n             FROM (\n                      SELECT ceil(reltuples / ((bs - page_hdr) / tpl_size)) + ceil(toasttuples / 4)                      AS est_tblpages,\n                             ceil(reltuples / ((bs - page_hdr) * fillfactor / (tpl_size * 100))) +\n                             ceil(toasttuples / 4)                                                                       AS est_tblpages_ff,\n                             tblpages,\n                             fillfactor,\n                             bs,\n                             tblid,\n                             schemaname,\n                             tblname,\n                             heappages,\n                             toastpages,\n                             is_na\n                             -- , stattuple.pgstattuple(tblid) AS pst\n                      FROM (\n                               SELECT (4 + tpl_hdr_size + tpl_data_size + (2 * ma)\n                                   - CASE WHEN tpl_hdr_size % ma = 0 THEN ma ELSE tpl_hdr_size % ma END\n                                   - CASE\n                                         WHEN ceil(tpl_data_size)::int % ma = 0 THEN ma\n                                         ELSE ceil(tpl_data_size)::int % ma END\n                                          )                    AS tpl_size,\n                                      bs - page_hdr            AS size_per_block,\n                                      (heappages + toastpages) AS tblpages,\n                                      heappages,\n                                      toastpages,\n                                      reltuples,\n                                      toasttuples,\n                                      bs,\n                                      page_hdr,\n                                      tblid,\n                                      schemaname,\n                                      tblname,\n                                      fillfactor,\n                                      is_na\n                               FROM (\n                                        SELECT tbl.oid                                                           AS tblid,\n                                               ns.nspname                                                        AS schemaname,\n                                               tbl.relname                                                       AS tblname,\n                                               tbl.reltuples,\n                                               tbl.relpages                                                      AS heappages,\n                                               coalesce(toast.relpages, 0)                                       AS toastpages,\n                                               coalesce(toast.reltuples, 0)                                      AS toasttuples,\n                                               coalesce(substring(\n                                                                array_to_string(tbl.reloptions, ' ')\n                                                                FROM 'fillfactor=([0-9]+)')::smallint,\n                                                        100)                                                     AS fillfactor,\n                                               current_setting('block_size')::numeric                            AS bs,\n                                               CASE\n                                                   WHEN version() ~ 'mingw32' OR version() ~ '64-bit|x86_64|ppc64|ia64|amd64'\n                                                       THEN 8\n                                                   ELSE 4 END                                                    AS ma,\n                                               24                                                                AS page_hdr,\n                                               23 + CASE\n                                                        WHEN MAX(coalesce(null_frac, 0)) > 0 THEN (7 + count(*)) / 8\n                                                        ELSE 0::int END\n                                                   +\n                                               CASE WHEN tbl.relhasoids THEN 4 ELSE 0 END                        AS tpl_hdr_size,\n                                               sum((1 - coalesce(s.null_frac, 0)) * coalesce(s.avg_width, 1024)) AS tpl_data_size,\n                                               bool_or(att.atttypid = 'pg_catalog.name'::regtype)\n                                                   OR count(att.attname) <> count(s.attname)                     AS is_na\n                                        FROM pg_attribute AS att\n                                                 JOIN pg_class AS tbl ON att.attrelid = tbl.oid\n                                                 JOIN pg_namespace AS ns ON ns.oid = tbl.relnamespace\n                                                 LEFT JOIN pg_stats AS s ON s.schemaname = ns.nspname\n                                            AND s.tablename = tbl.relname AND s.inherited = false AND\n                                                                            s.attname = att.attname\n                                                 LEFT JOIN pg_class AS toast ON tbl.reltoastrelid = toast.oid\n                                        WHERE att.attnum > 0\n                                          AND NOT att.attisdropped\n                                          AND tbl.relkind IN ('r', 'm')\n                                          AND ns.nspname != 'information_schema'\n                                        GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, tbl.relhasoids\n                                        ORDER BY 2, 3\n                                    ) AS s\n                           ) AS s2\n                  ) AS s3\n             -- WHERE NOT is_na\n         ) s4\n)\nSELECT\n    (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n    (select sum(approx_bloat_bytes) from q_bloat) as approx_table_bloat_b,\n    ((select sum(approx_bloat_bytes) from q_bloat) * 100 / pg_database_size(current_database()))::int8 as approx_bloat_percentage;\n
41	table_bloat_approx_summary_sql	12	\nWITH q_bloat AS (\n    select * from get_table_bloat_approx_sql()\n)\nSELECT\n    (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n    (select sum(approx_bloat_bytes) from q_bloat) as approx_table_bloat_b,\n    ((select sum(approx_bloat_bytes) from q_bloat) * 100 / pg_database_size(current_database()))::int8 as approx_bloat_percentage\n;\n	\N	t	f	2019-10-04 22:09:34.772973-07	t	f	{"prometheus_all_gauge_columns": true}	\nWITH q_bloat AS (\n    SELECT quote_ident(schemaname) || '.' || quote_ident(tblname) as full_table_name,\n           bloat_ratio                                            as approx_bloat_percent,\n           bloat_size                                             as approx_bloat_bytes,\n           fillfactor\n    FROM (\n\n/* WARNING: executed with a non-superuser role, the query inspect only tables you are granted to read.\n* This query is compatible with PostgreSQL 9.0 and more\n*/\n             SELECT current_database(),\n                    schemaname,\n                    tblname,\n                    bs * tblpages                  AS real_size,\n                    (tblpages - est_tblpages) * bs AS extra_size,\n                    CASE\n                        WHEN tblpages - est_tblpages > 0\n                            THEN 100 * (tblpages - est_tblpages) / tblpages::float\n                        ELSE 0\n                        END                        AS extra_ratio,\n                    fillfactor,\n                    CASE\n                        WHEN tblpages - est_tblpages_ff > 0\n                            THEN (tblpages - est_tblpages_ff) * bs\n                        ELSE 0\n                        END                        AS bloat_size,\n                    CASE\n                        WHEN tblpages - est_tblpages_ff > 0\n                            THEN 100 * (tblpages - est_tblpages_ff) / tblpages::float\n                        ELSE 0\n                        END                        AS bloat_ratio,\n                    is_na\n                    -- , (pst).free_percent + (pst).dead_tuple_percent AS real_frag\n             FROM (\n                      SELECT ceil(reltuples / ((bs - page_hdr) / tpl_size)) + ceil(toasttuples / 4) AS est_tblpages,\n                             ceil(reltuples / ((bs - page_hdr) * fillfactor / (tpl_size * 100))) +\n                             ceil(toasttuples / 4)                                                  AS est_tblpages_ff,\n                             tblpages,\n                             fillfactor,\n                             bs,\n                             tblid,\n                             schemaname,\n                             tblname,\n                             heappages,\n                             toastpages,\n                             is_na\n                             -- , stattuple.pgstattuple(tblid) AS pst\n                      FROM (\n                               SELECT (4 + tpl_hdr_size + tpl_data_size + (2 * ma)\n                                   - CASE WHEN tpl_hdr_size % ma = 0 THEN ma ELSE tpl_hdr_size % ma END\n                                   - CASE\n                                         WHEN ceil(tpl_data_size)::int % ma = 0 THEN ma\n                                         ELSE ceil(tpl_data_size)::int % ma END\n                                          )                    AS tpl_size,\n                                      bs - page_hdr            AS size_per_block,\n                                      (heappages + toastpages) AS tblpages,\n                                      heappages,\n                                      toastpages,\n                                      reltuples,\n                                      toasttuples,\n                                      bs,\n                                      page_hdr,\n                                      tblid,\n                                      schemaname,\n                                      tblname,\n                                      fillfactor,\n                                      is_na\n                               FROM (\n                                        SELECT tbl.oid                                                           AS tblid,\n                                               ns.nspname                                                        AS schemaname,\n                                               tbl.relname                                                       AS tblname,\n                                               tbl.reltuples,\n                                               tbl.relpages                                                      AS heappages,\n                                               coalesce(toast.relpages, 0)                                       AS toastpages,\n                                               coalesce(toast.reltuples, 0)                                      AS toasttuples,\n                                               coalesce(substring(\n                                                                array_to_string(tbl.reloptions, ' ')\n                                                                FROM 'fillfactor=([0-9]+)')::smallint,\n                                                        100)                                                     AS fillfactor,\n                                               current_setting('block_size')::numeric                            AS bs,\n                                               CASE\n                                                   WHEN version() ~ 'mingw32' OR version() ~ '64-bit|x86_64|ppc64|ia64|amd64'\n                                                       THEN 8\n                                                   ELSE 4 END                                                    AS ma,\n                                               24                                                                AS page_hdr,\n                                               23 + CASE\n                                                        WHEN MAX(coalesce(null_frac, 0)) > 0 THEN (7 + count(*)) / 8\n                                                        ELSE 0::int END\n                                                   +\n                                               0                                                                 AS tpl_hdr_size,\n                                               sum((1 - coalesce(s.null_frac, 0)) * coalesce(s.avg_width, 1024)) AS tpl_data_size,\n                                               bool_or(att.atttypid = 'pg_catalog.name'::regtype)\n                                                   OR\n                                               count(att.attname) <> count(s.attname)                            AS is_na\n                                        FROM pg_attribute AS att\n                                                 JOIN pg_class AS tbl ON att.attrelid = tbl.oid\n                                                 JOIN pg_namespace AS ns ON ns.oid = tbl.relnamespace\n                                                 LEFT JOIN pg_stats AS s ON s.schemaname = ns.nspname\n                                            AND s.tablename = tbl.relname AND s.inherited = false AND\n                                                                            s.attname = att.attname\n                                                 LEFT JOIN pg_class AS toast ON tbl.reltoastrelid = toast.oid\n                                        WHERE att.attnum > 0\n                                          AND NOT att.attisdropped\n                                          AND tbl.relkind IN ('r', 'm')\n                                          AND ns.nspname != 'information_schema'\n                                        GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n                                        ORDER BY 2, 3\n                                    ) AS s\n                           ) AS s2\n                  ) AS s3\n             -- WHERE NOT is_na\n         ) s4\n)\nSELECT\n    (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n    (select sum(approx_bloat_bytes) from q_bloat) as approx_table_bloat_b,\n    ((select sum(approx_bloat_bytes) from q_bloat) * 100 / pg_database_size(current_database()))::int8 as approx_bloat_percentage;\n
42	change_events	9.0	\n	\N	t	f	2019-10-04 22:09:34.773938-07	f	f	\N	
43	sproc_hashes	9.0	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  p.oid::text as tag_oid,\n  quote_ident(nspname)||'.'||quote_ident(proname) as tag_sproc,\n  md5(prosrc)\nfrom\n  pg_proc p\n  join\n  pg_namespace n on n.oid = pronamespace\nwhere\n  not nspname like any(array[E'pg\\\\_%', 'information_schema']);\n	\N	t	f	2019-10-04 22:09:34.774326-07	f	f	\N	
44	table_hashes	9.0	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  quote_ident(table_schema)||'.'||quote_ident(table_name) as tag_table,\n  md5((array_agg((c.*)::text order by ordinal_position))::text)\nfrom (\n SELECT current_database()::information_schema.sql_identifier AS table_catalog,\n    nc.nspname::information_schema.sql_identifier AS table_schema,\n    c.relname::information_schema.sql_identifier AS table_name,\n    a.attname::information_schema.sql_identifier AS column_name,\n    a.attnum::information_schema.cardinal_number AS ordinal_position,\n    pg_get_expr(ad.adbin, ad.adrelid)::information_schema.character_data AS column_default,\n        CASE\n            WHEN a.attnotnull OR t.typtype = 'd'::"char" AND t.typnotnull THEN 'NO'::text\n            ELSE 'YES'::text\n        END::information_schema.yes_or_no AS is_nullable,\n        CASE\n            WHEN t.typtype = 'd'::"char" THEN\n            CASE\n                WHEN bt.typelem <> 0::oid AND bt.typlen = '-1'::integer THEN 'ARRAY'::text\n                WHEN nbt.nspname = 'pg_catalog'::name THEN format_type(t.typbasetype, NULL::integer)\n                ELSE 'USER-DEFINED'::text\n            END\n            ELSE\n            CASE\n                WHEN t.typelem <> 0::oid AND t.typlen = '-1'::integer THEN 'ARRAY'::text\n                WHEN nt.nspname = 'pg_catalog'::name THEN format_type(a.atttypid, NULL::integer)\n                ELSE 'USER-DEFINED'::text\n            END\n        END::information_schema.character_data AS data_type,\n    information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number AS character_maximum_length,\n    information_schema._pg_char_octet_length(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number AS character_octet_length,\n    information_schema._pg_numeric_precision(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number AS numeric_precision,\n    information_schema._pg_numeric_precision_radix(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number AS numeric_precision_radix,\n    information_schema._pg_numeric_scale(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number AS numeric_scale,\n    information_schema._pg_datetime_precision(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number AS datetime_precision,\n    information_schema._pg_interval_type(information_schema._pg_truetypid(a.*, t.*), information_schema._pg_truetypmod(a.*, t.*))::information_schema.character_data AS interval_type,\n    NULL::integer::information_schema.cardinal_number AS interval_precision,\n    NULL::character varying::information_schema.sql_identifier AS character_set_catalog,\n    NULL::character varying::information_schema.sql_identifier AS character_set_schema,\n    NULL::character varying::information_schema.sql_identifier AS character_set_name,\n        CASE\n            WHEN nco.nspname IS NOT NULL THEN current_database()\n            ELSE NULL::name\n        END::information_schema.sql_identifier AS collation_catalog,\n    nco.nspname::information_schema.sql_identifier AS collation_schema,\n    co.collname::information_schema.sql_identifier AS collation_name,\n        CASE\n            WHEN t.typtype = 'd'::"char" THEN current_database()\n            ELSE NULL::name\n        END::information_schema.sql_identifier AS domain_catalog,\n        CASE\n            WHEN t.typtype = 'd'::"char" THEN nt.nspname\n            ELSE NULL::name\n        END::information_schema.sql_identifier AS domain_schema,\n        CASE\n            WHEN t.typtype = 'd'::"char" THEN t.typname\n            ELSE NULL::name\n        END::information_schema.sql_identifier AS domain_name,\n    current_database()::information_schema.sql_identifier AS udt_catalog,\n    COALESCE(nbt.nspname, nt.nspname)::information_schema.sql_identifier AS udt_schema,\n    COALESCE(bt.typname, t.typname)::information_schema.sql_identifier AS udt_name,\n    NULL::character varying::information_schema.sql_identifier AS scope_catalog,\n    NULL::character varying::information_schema.sql_identifier AS scope_schema,\n    NULL::character varying::information_schema.sql_identifier AS scope_name,\n    NULL::integer::information_schema.cardinal_number AS maximum_cardinality,\n    a.attnum::information_schema.sql_identifier AS dtd_identifier,\n    'NO'::character varying::information_schema.yes_or_no AS is_self_referencing,\n    'NO'::character varying::information_schema.yes_or_no AS is_identity,\n    NULL::character varying::information_schema.character_data AS identity_generation,\n    NULL::character varying::information_schema.character_data AS identity_start,\n    NULL::character varying::information_schema.character_data AS identity_increment,\n    NULL::character varying::information_schema.character_data AS identity_maximum,\n    NULL::character varying::information_schema.character_data AS identity_minimum,\n    NULL::character varying::information_schema.yes_or_no AS identity_cycle,\n    'NEVER'::character varying::information_schema.character_data AS is_generated,\n    NULL::character varying::information_schema.character_data AS generation_expression,\n        CASE\n            WHEN c.relkind = 'r'::"char" OR (c.relkind = ANY (ARRAY['v'::"char", 'f'::"char"])) AND pg_column_is_updatable(c.oid::regclass, a.attnum, false) THEN 'YES'::text\n            ELSE 'NO'::text\n        END::information_schema.yes_or_no AS is_updatable\n   FROM pg_attribute a\n     LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid AND a.attnum = ad.adnum\n     JOIN (pg_class c\n     JOIN pg_namespace nc ON c.relnamespace = nc.oid) ON a.attrelid = c.oid\n     JOIN (pg_type t\n     JOIN pg_namespace nt ON t.typnamespace = nt.oid) ON a.atttypid = t.oid\n     LEFT JOIN (pg_type bt\n     JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid) ON t.typtype = 'd'::"char" AND t.typbasetype = bt.oid\n     LEFT JOIN (pg_collation co\n     JOIN pg_namespace nco ON co.collnamespace = nco.oid) ON a.attcollation = co.oid AND (nco.nspname <> 'pg_catalog'::name OR co.collname <> 'default'::name)\n  WHERE NOT pg_is_other_temp_schema(nc.oid) AND a.attnum > 0 AND NOT a.attisdropped AND (c.relkind = ANY (ARRAY['r'::"char", 'v'::"char", 'f'::"char"]))\n\n) c\nwhere\n  not table_schema like any (array[E'pg\\\\_%', 'information_schema'])\ngroup by\n  table_schema, table_name\norder by\n  table_schema, table_name;\n	\N	t	f	2019-10-04 22:09:34.774921-07	f	f	\N	
45	configuration_hashes	9.0	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  name as tag_setting,\n  coalesce(reset_val, '') as value\nfrom\n  pg_settings;\n	\N	t	f	2019-10-04 22:09:34.775607-07	f	f	\N	
46	index_hashes	9.0	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  quote_ident(nspname)||'.'||quote_ident(c.relname) as tag_index,\n  quote_ident(nspname)||'.'||quote_ident(r.relname) as "table",\n  i.indisvalid::text as is_valid,\n  coalesce(md5(pg_get_indexdef(i.indexrelid)), random()::text) as md5\nfrom\n  pg_index i\n  join\n  pg_class c on c.oid = i.indexrelid\n  join\n  pg_class r on r.oid = i.indrelid\n  join\n  pg_namespace n on n.oid = c.relnamespace\nwhere\n  c.relnamespace not in (select oid from pg_namespace where nspname like any(array[E'pg\\\\_%', 'information_schema']));\n	\N	t	f	2019-10-04 22:09:34.775983-07	f	f	\N	
47	get_load_average	9.0	\nBEGIN;\n\nCREATE EXTENSION IF NOT EXISTS plpythonu;\n\nCREATE OR REPLACE FUNCTION get_load_average(OUT load_1min float, OUT load_5min float, OUT load_15min float) AS\n$$\nfrom os import getloadavg\nla = getloadavg()\nreturn [la[0], la[1], la[2]]\n$$ LANGUAGE plpythonu VOLATILE SECURITY DEFINER;\n\nGRANT EXECUTE ON FUNCTION get_load_average() TO pgwatch2;\n\nCOMMENT ON FUNCTION get_load_average() is 'created for pgwatch2';\n\nCOMMIT;\n	for internal usage - when connecting user is marked as superuser then the daemon will automatically try to create the needed helpers on the monitored db	t	t	2019-10-04 22:09:34.776335-07	f	f	\N	
48	get_stat_statements	9.0	\nCREATE EXTENSION IF NOT EXISTS pg_stat_statements;\n\nDO $OUTER$\nDECLARE\n  l_sproc_text text := $_SQL_$\nCREATE OR REPLACE FUNCTION get_stat_statements() RETURNS SETOF pg_stat_statements AS\n$$\n  select s.* from pg_stat_statements s join pg_database d on d.oid = s.dbid and d.datname = current_database()\n$$ LANGUAGE sql VOLATILE SECURITY DEFINER;\n$_SQL_$;\nBEGIN\n  IF (regexp_matches(\n  \t\tregexp_replace(current_setting('server_version'), '(beta|devel).*', '', 'g'),\n        E'\\\\d+\\\\.?\\\\d+?')\n      )[1]::double precision > 9.1 THEN   --parameters normalized only from 9.2\n    EXECUTE 'CREATE EXTENSION IF NOT EXISTS pg_stat_statements';\n    EXECUTE format(l_sproc_text);    \n    EXECUTE 'GRANT EXECUTE ON FUNCTION get_stat_statements() TO pgwatch2';\n    EXECUTE 'COMMENT ON FUNCTION get_stat_statements() IS ''created for pgwatch2''';\n  END IF;\nEND;\n$OUTER$;\n	for internal usage - when connecting user is marked as superuser then the daemon will automatically try to create the needed helpers on the monitored db	t	t	2019-10-04 22:09:34.776722-07	f	f	\N	
49	pgbouncer_stats	0	show stats	pgbouncer per db statistics	t	f	2019-10-04 22:09:34.777048-07	f	f	\N	
50	get_stat_activity	9.0	\n\nDO $OUTER$\nDECLARE\n  l_pgver double precision;\n  l_sproc_text_pre92 text := $SQL$\nCREATE OR REPLACE FUNCTION get_stat_activity() RETURNS SETOF pg_stat_activity AS\n$$\n  select * from pg_stat_activity where datname = current_database() and procpid != pg_backend_pid()\n$$ LANGUAGE sql VOLATILE SECURITY DEFINER;\n$SQL$;\n  l_sproc_text_92_plus text := $SQL$\nCREATE OR REPLACE FUNCTION get_stat_activity() RETURNS SETOF pg_stat_activity AS\n$$\n  select * from pg_stat_activity where datname = current_database() and pid != pg_backend_pid()\n$$ LANGUAGE sql VOLATILE SECURITY DEFINER;\n$SQL$;\nBEGIN\n  SELECT ((regexp_matches(\n      regexp_replace(current_setting('server_version'), '(beta|devel).*', '', 'g'),\n        E'\\\\d+\\\\.?\\\\d+?'))[1])::double precision INTO l_pgver;\n  EXECUTE format(CASE WHEN l_pgver > 9.1 THEN l_sproc_text_92_plus ELSE l_sproc_text_pre92 END);\nEND;\n$OUTER$;\n\nGRANT EXECUTE ON FUNCTION get_stat_activity() TO pgwatch2;\nCOMMENT ON FUNCTION get_stat_activity() IS 'created for pgwatch2';\n\n	for internal usage - when connecting user is marked as superuser then the daemon will automatically try to create the needed helpers on the monitored db	t	t	2019-10-04 22:09:34.777473-07	f	f	\N	
51	replication_slots	9.4	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  slot_name::text as tag_slot_name,\n  coalesce(plugin, 'physical')::text as tag_plugin,\n  active,\n  case when active then 0 else 1 end as non_active_int,\n  pg_xlog_location_diff(pg_current_xlog_location(), restart_lsn)::int8 as restart_lsn_lag_b,\n  greatest(age(xmin), age(catalog_xmin))::int8 as xmin_age_tx\nfrom\n  pg_replication_slots;\n	\N	t	f	2019-10-04 22:09:34.777842-07	t	f	{"prometheus_all_gauge_columns": true}	
52	replication_slots	10	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  slot_name::text as tag_slot_name,\n  coalesce(plugin, 'physical')::text as plugin,\n  active,\n  case when active then 0 else 1 end as non_active_int,\n  pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn)::int8 as restart_lsn_lag_b,\n  greatest(age(xmin), age(catalog_xmin))::int8 as xmin_age_tx\nfrom\n  pg_replication_slots;\n	\N	t	f	2019-10-04 22:09:34.778203-07	t	f	{"prometheus_all_gauge_columns": true}	
53	psutil_cpu	9.0	\n\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  cpu_utilization, load_1m_norm, load_1m, load_5m_norm, load_5m,\n  "user", system, idle, iowait, irqs, other\nfrom\n  get_psutil_cpu();\n	\N	t	f	2019-10-04 22:09:34.778544-07	f	f	{"prometheus_all_gauge_columns": true}	
54	psutil_mem	9.0	\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  total, used, free, buff_cache, available, percent,\n  swap_total, swap_used, swap_free, swap_percent\nfrom\n  get_psutil_mem();\n	\N	t	f	2019-10-04 22:09:34.778856-07	f	f	{"prometheus_all_gauge_columns": true}	
55	psutil_disk	9.0	\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  dir_or_tablespace as tag_dir_or_tablespace,\n  path as tag_path,\n  total, used, free, percent\nfrom\n  get_psutil_disk();\n	\N	t	f	2019-10-04 22:09:34.779152-07	f	f	{"prometheus_all_gauge_columns": true}	
56	psutil_disk_io_total	9.0	\nSELECT\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  read_count,\n  write_count,\n  read_bytes,\n  write_bytes\nfrom\n  get_psutil_disk_io_total();\n	\N	t	f	2019-10-04 22:09:34.779441-07	f	f	{"prometheus_all_gauge_columns": true}	
57	archiver	9.4	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  archived_count,\n  failed_count,\n  case when coalesce(last_failed_time, '1970-01-01'::timestamptz) > coalesce(last_archived_time, '1970-01-01'::timestamptz) then 1 else 0 end as is_failing_int,\n  extract(epoch from now() - last_failed_time)::int8 as seconds_since_last_failure\nfrom\n  pg_stat_archiver\nwhere\n  current_setting('archive_mode') in ('on', 'always');\n	\N	t	f	2019-10-04 22:09:34.779782-07	f	f	{"prometheus_gauge_columns": ["is_failing_int", "seconds_since_last_failure"]}	
58	get_wal_size	10	\n\nCREATE OR REPLACE FUNCTION get_wal_size() RETURNS int8 AS\n$$\nselect (sum((pg_stat_file('pg_wal/' || name)).size))::int8 from pg_ls_waldir()\n$$ LANGUAGE sql VOLATILE SECURITY DEFINER;\n\nGRANT EXECUTE ON FUNCTION get_wal_size() TO pgwatch2;\nCOMMENT ON FUNCTION get_wal_size() IS 'created for pgwatch2';\n\n	for internal usage - when connecting user is marked as superuser then the daemon will automatically try to create the needed helpers on the monitored db	t	t	2019-10-04 22:09:34.78015-07	f	f	\N	
59	wal_size	9.0		\N	t	f	2019-10-04 22:09:34.780439-07	f	f	\N	
60	wal_size	10	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  get_wal_size() as wal_size_b;\n	\N	t	f	2019-10-04 22:09:34.780737-07	f	f	{"prometheus_all_gauge_columns": true}	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n   (sum((pg_stat_file('pg_wal/' || name)).size))::int8 as wal_size_b\nfrom pg_ls_waldir();\n
61	wal_receiver	9.2	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  pg_xlog_location_diff(pg_last_xlog_receive_location(), pg_last_xlog_replay_location()) as replay_lag_b,\n  extract(epoch from (now() - pg_last_xact_replay_timestamp()))::int8 as last_replay_s;\n	\N	t	f	2019-10-04 22:09:34.781039-07	f	t	{"prometheus_all_gauge_columns": true}	
62	wal_receiver	9.6	\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  pg_wal_lsn_diff(pg_last_wal_receive_lsn(), pg_last_wal_replay_lsn()) as replay_lag_b,\n  extract(epoch from (now() - pg_last_xact_replay_timestamp()))::int8 as last_replay_s;\n	\N	t	f	2019-10-04 22:09:34.781401-07	f	t	{"prometheus_all_gauge_columns": true}	
63	get_stat_replication	9.0	\n\nCREATE OR REPLACE FUNCTION get_stat_replication() RETURNS SETOF pg_stat_replication AS\n$$\n  select * from pg_stat_replication\n$$ LANGUAGE sql VOLATILE SECURITY DEFINER;\n\nGRANT EXECUTE ON FUNCTION get_stat_replication() TO pgwatch2;\nCOMMENT ON FUNCTION get_stat_replication() IS 'created for pgwatch2';\n\n	for internal usage - when connecting user is marked as superuser then the daemon will automatically try to create the needed helpers on the monitored db	t	t	2019-10-04 22:09:34.781748-07	f	f	\N	
64	settings	9.0	\nwith qs as (\n  select name, setting from pg_settings\n)\nselect\n  (extract(epoch from now()) * 1e9)::int8 as epoch_ns,\n  current_setting('server_version') as server_version,\n  current_setting('server_version_num')::int8 as server_version_num,\n  current_setting('block_size')::int as block_size,\n  current_setting('max_connections')::int as max_connections,\n  current_setting('hot_standby') as hot_standby,\n  (select setting from qs where name = 'hot_standby_feedback') as hot_standby_feedback,\n  current_setting('fsync') as fsync,\n  current_setting('full_page_writes') as full_page_writes,\n  current_setting('synchronous_commit') as synchronous_commit,\n  (select setting from qs where name = 'wal_compression') as wal_compression,\n  (select setting from qs where name = 'wal_log_hints') as wal_log_hints,\n  (select setting from qs where name = 'synchronous_standby_names') as synchronous_standby_names,\n  current_setting('shared_buffers') as shared_buffers,\n  current_setting('work_mem') as work_mem,\n  current_setting('maintenance_work_mem') as maintenance_work_mem,\n  current_setting('effective_cache_size') as effective_cache_size,\n  (select setting::int8 from qs where name = 'default_statistics_target') as default_statistics_target,\n  (select setting::float8 from qs where name = 'random_page_cost') as random_page_cost,\n  pg_size_pretty(((select setting::int8 from qs where name = 'min_wal_size') * 1024^2)::int8) as min_wal_size,\n  pg_size_pretty(((select setting::int8 from qs where name = 'max_wal_size') * 1024^2)::int8) as max_wal_size,\n  (select setting from qs where name = 'checkpoint_segments') as checkpoint_segments,\n  current_setting('checkpoint_timeout') as checkpoint_timeout,\n  current_setting('checkpoint_completion_target') as checkpoint_completion_target,\n  (select setting::int8 from qs where name = 'max_worker_processes') as max_worker_processes,\n  (select setting::int8 from qs where name = 'max_parallel_workers') as max_parallel_workers,\n  (select setting::int8 from qs where name = 'max_parallel_workers_per_gather') as max_parallel_workers_per_gather,\n  (select case when setting = 'on' then 1 else 0 end from qs where name = 'jit') as jit,\n  (select case when setting = 'on' then 1 else 0 end from qs where name = 'ssl') as ssl,\n  current_setting('statement_timeout') as statement_timeout,\n  current_setting('deadlock_timeout') as deadlock_timeout,\n  (select setting from qs where name = 'data_checksums') as data_checksums,\n  (select setting::int8 from qs where name = 'max_connections') as max_connections,\n  (select setting::int8 from qs where name = 'max_wal_senders') as max_wal_senders,\n  (select setting::int8 from qs where name = 'max_replication_slots') as max_replication_slots,\n  (select setting::int8 from qs where name = 'max_prepared_transactions') as max_prepared_transactions,\n  (select setting::int8 from qs where name = 'lock_timeout') || ' (ms)' as lock_timeout,\n  (select setting from qs where name = 'archive_mode') as archive_mode,\n  (select setting from qs where name = 'archive_command') as archive_command,\n  current_setting('archive_timeout') as archive_timeout,\n  (select setting from qs where name = 'shared_preload_libraries') as shared_preload_libraries,\n  (select setting from qs where name = 'listen_addresses') as listen_addresses,\n  (select setting from qs where name = 'ssl') as ssl,\n  (select setting from qs where name = 'autovacuum') as autovacuum,\n  (select setting::int8 from qs where name = 'autovacuum_max_workers') as autovacuum_max_workers,\n  (select setting::float8 from qs where name = 'autovacuum_vacuum_scale_factor') as autovacuum_vacuum_scale_factor,\n  (select setting::float8 from qs where name = 'autovacuum_vacuum_threshold') as autovacuum_vacuum_threshold,\n  (select setting::float8 from qs where name = 'autovacuum_analyze_scale_factor') as autovacuum_analyze_scale_factor,\n  (select setting::float8 from qs where name = 'autovacuum_analyze_threshold') as autovacuum_analyze_scale_factor\n;\n	\N	t	f	2019-10-04 22:09:34.782193-07	f	f	{"prometheus_all_gauge_columns": true}	
\.


--
-- Name: metric_m_id_seq; Type: SEQUENCE SET; Schema: pgwatch2; Owner: pgwatch2
--

SELECT pg_catalog.setval('pgwatch2.metric_m_id_seq', 64, true);


--
-- PostgreSQL database dump complete
--

